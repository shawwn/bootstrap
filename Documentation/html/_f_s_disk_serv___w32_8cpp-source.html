<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Bootstrap Engine: C:/Bootstrap/ProjectBX/Documentation/Code/Engine/FileSystem/FSDiskServ_W32.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>C:/Bootstrap/ProjectBX/Documentation/Code/Engine/FileSystem/FSDiskServ_W32.cpp</h1><a href="_f_s_disk_serv___w32_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//----------------------------------------------------------</span>
<a name="l00006"></a>00006 <span class="comment"></span><span class="comment">//----------------------------------------------------------</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include "<a class="code" href="filesystem__afx_8h.html">filesystem_afx.h</a>"</span>
<a name="l00008"></a>00008 
<a name="l00010"></a>00010 <span class="preprocessor">#include "<a class="code" href="_f_s_disk_serv_8h.html">FSDiskServ.h</a>"</span>
<a name="l00011"></a>00011 
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;process.h&gt;</span>
<a name="l00014"></a>00014 
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;WinIoCtl.h&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;tchar.h&gt;</span>
<a name="l00018"></a>00018 
<a name="l00022"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#1bd31ca46edf8a2f66c3890a2dbbe564">00022</a> <span class="preprocessor">#define BLOCKS_PER_ALLOCATION           1024</span>
<a name="l00023"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#f4832b48e562107b481016b88342a01a">00023</a> <span class="preprocessor"></span><span class="preprocessor">#define MAX_BLOCK_COUNT                         1024</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span>
<a name="l00027"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#ecc4c5fadbda3d12a5a810f93cf2fe43">00027</a> <span class="preprocessor">#define MAX_PENDING_IO                          1024</span>
<a name="l00028"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#9d1051fc423c95127cfd80141482f402">00028</a> <span class="preprocessor"></span><span class="preprocessor">#define MAX_DRIVE_COUNT                         32</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span>
<a name="l00031"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#2a4fe9cb315ee694da76ba944eaf709a">00031</a> <span class="preprocessor">#define DTYPE_UNKNOWN                           0</span>
<a name="l00032"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#59280ff0687459cac3fb71320979ffb4">00032</a> <span class="preprocessor"></span><span class="preprocessor">#define DTYPE_HDD                                       1</span>
<a name="l00033"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#96150d499acf07fef7ded70fd4fa64f9">00033</a> <span class="preprocessor"></span><span class="preprocessor">#define DTYPE_CD                                        2</span>
<a name="l00034"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#0585de32c9d4f05c6ffdac6cb1250a66">00034</a> <span class="preprocessor"></span><span class="preprocessor">#define DTYPE_DVD                                       3</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span><span class="comment">//#define DTYPE_HDDVD                           4</span>
<a name="l00036"></a>00036 <span class="comment">//#define DTYPE_BLUERAY                         5</span>
<a name="l00037"></a>00037 
<a name="l00041"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#05ce56e00d6fd51940257e8718ba3a88">00041</a> <span class="preprocessor">#define DISKCACHE_SIZE_HDD                              262144</span>
<a name="l00042"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#dc1c85a7d6e638c59856846ef388ec3e">00042</a> <span class="preprocessor"></span><span class="preprocessor">#define DISKCACHE_SIZE_CD                               131072</span>
<a name="l00043"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#4a3a2dd180a995d513762c53c95bd598">00043</a> <span class="preprocessor"></span><span class="preprocessor">#define DISKCACHE_SIZE_DVD                              131072</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span>
<a name="l00045"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#7bbed87240f78355659b4285558e6a55">00045</a> <span class="preprocessor">#define LOOKAHEAD_SIZE_HDD                              65536</span>
<a name="l00046"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#c88e4ff9f0777c5ae5464096aa000832">00046</a> <span class="preprocessor"></span><span class="preprocessor">#define LOOKAHEAD_SIZE_CD                               65536</span>
<a name="l00047"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#af5e2dcc3f408e04b8ec74c129404749">00047</a> <span class="preprocessor"></span><span class="preprocessor">#define LOOKAHEAD_SIZE_DVD                              65536</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span>
<a name="l00049"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#2177b3fe8493058fb7fa092ecf8bdbd6">00049</a> <span class="preprocessor">#define LOOKAHEAD_COUNT_HDD                             128</span>
<a name="l00050"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#73bbedde51b2263293c087d4ee3a45a9">00050</a> <span class="preprocessor"></span><span class="preprocessor">#define LOOKAHEAD_COUNT_CD                              512</span>
<a name="l00051"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#a7e35654383715365ac83c6dc625d43d">00051</a> <span class="preprocessor"></span><span class="preprocessor">#define LOOKAHEAD_COUNT_DVD                             512</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span>
<a name="l00053"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#4f2067f0c6d65cc2382026aae315e15f">00053</a> <span class="preprocessor">#define SEEKBACK_SIZE_HDD                               8388608</span>
<a name="l00054"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#7d9a55bc9b2f042ecb83d94fe0e6aea1">00054</a> <span class="preprocessor"></span><span class="preprocessor">#define SEEKBACK_SIZE_CD                                2097152</span>
<a name="l00055"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#7be663e58042a12b717c191c8ab8b5c5">00055</a> <span class="preprocessor"></span><span class="preprocessor">#define SEEKBACK_SIZE_DVD                               4194304</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span>
<a name="l00057"></a>00057 <span class="comment">//==========================================================</span>
<a name="l00059"></a>00059 <span class="comment"></span><span class="comment">//==========================================================</span>
<a name="l00060"></a>00060 
<a name="l00061"></a><a class="code" href="struct_s_file__t.html">00061</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_s_file__t.html" title="internal structures.">SFile_t</a>
<a name="l00062"></a>00062 {
<a name="l00063"></a><a class="code" href="struct_s_file__t.html#9c5b15b8c07aca9928c6a347e765d60f">00063</a>         <span class="keyword">volatile</span> <a class="code" href="wglext_8h.html#a1efb7b85228601549d183556de19dfc">HANDLE</a> <a class="code" href="struct_s_file__t.html#9c5b15b8c07aca9928c6a347e765d60f">handle</a>;                                         
<a name="l00064"></a><a class="code" href="struct_s_file__t.html#4dafbf10076baf07fe478e79a33fdc8b">00064</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>  <a class="code" href="struct_s_file__t.html#4dafbf10076baf07fe478e79a33fdc8b" title="Win32 file handle.">flags</a>;                                          
<a name="l00065"></a><a class="code" href="struct_s_file__t.html#21b0d1399a43df9577404c7b2004c5b4">00065</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>  <a class="code" href="struct_s_file__t.html#21b0d1399a43df9577404c7b2004c5b4" title="creation flags.">drive</a>;                                          
<a name="l00066"></a><a class="code" href="struct_s_file__t.html#3ec63209feb76e69e0d6be30d3cae074">00066</a>         <a class="code" href="filesystem__afx_8h.html#2dfedf2033eee861d23c808f79ed5837">FSsize</a>                  <a class="code" href="struct_s_file__t.html#3ec63209feb76e69e0d6be30d3cae074" title="the drive on which the file is located.">offset</a>;                                         
<a name="l00067"></a><a class="code" href="struct_s_file__t.html#28381f30fa5e5f18fd8c6e6d7f2a76f3">00067</a>         <a class="code" href="filesystem__afx_8h.html#2dfedf2033eee861d23c808f79ed5837">FSsize</a>                  <a class="code" href="struct_s_file__t.html#28381f30fa5e5f18fd8c6e6d7f2a76f3" title="absolute file offset.">physAddr</a>;                                       
<a name="l00068"></a><a class="code" href="struct_s_file__t.html#efe9a20ae13e8a4b3d92770f7f042493">00068</a>         <span class="keyword">volatile</span> <span class="keyword">struct </span><a class="code" href="struct_s_file__t.html" title="internal structures.">SFile_t</a>* <a class="code" href="struct_s_file__t.html#efe9a20ae13e8a4b3d92770f7f042493" title="start on the hard-drive.">nextFree</a>;                      
<a name="l00069"></a>00069 } <a class="code" href="struct_s_file__t.html" title="internal structures.">SFile</a>;
<a name="l00070"></a>00070 
<a name="l00071"></a><a class="code" href="struct_s_file_op__t.html">00071</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_s_file_op__t.html">SFileOp_t</a>
<a name="l00072"></a>00072 {
<a name="l00073"></a><a class="code" href="struct_s_file_op__t.html#7580e2d7725d9e62b6f01af716882b5a">00073</a>         OVERLAPPED                              <a class="code" href="struct_s_file_op__t.html#7580e2d7725d9e62b6f01af716882b5a">overlapped</a>;
<a name="l00074"></a><a class="code" href="struct_s_file_op__t.html#a85b29f1d72b6b477e9e4ba93f18be1c">00074</a>         <a class="code" href="struct_s_f_s_file_read_buffer__t.html" title="File structures.">SFSFileReadBuffer</a>*              <a class="code" href="struct_s_file_op__t.html#a85b29f1d72b6b477e9e4ba93f18be1c">readBuffer</a>;                     
<a name="l00075"></a><a class="code" href="struct_s_file_op__t.html#35a76a584a5395b66dc709e5a81a690a">00075</a>         <a class="code" href="struct_s_f_s_file_write_buffer__t.html">SFSFileWriteBuffer</a>*             <a class="code" href="struct_s_file_op__t.html#35a76a584a5395b66dc709e5a81a690a" title="non-zero for a read event.">writeBuffer</a>;            
<a name="l00076"></a><a class="code" href="struct_s_file_op__t.html#d11881794d5507b1eee0c41a840b7062">00076</a>         <a class="code" href="struct_s_file__t.html" title="internal structures.">SFile_t</a>*                                <a class="code" href="struct_s_file_op__t.html#d11881794d5507b1eee0c41a840b7062" title="non-zero for a write event.">file</a>;                           
<a name="l00077"></a><a class="code" href="struct_s_file_op__t.html#3d23fc9294b4099d03479ecc39867c5d">00077</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    <a class="code" href="struct_s_file_op__t.html#3d23fc9294b4099d03479ecc39867c5d" title="file pointer.">size</a>;                           
<a name="l00078"></a><a class="code" href="struct_s_file_op__t.html#b7c0b908f7ae23db0ed6963eb79335e8">00078</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    <a class="code" href="struct_s_file_op__t.html#b7c0b908f7ae23db0ed6963eb79335e8" title="amount of data to read/write.">retired</a>;                        
<a name="l00079"></a><a class="code" href="struct_s_file_op__t.html#5d5cf61968a0cb6006012635d2754544">00079</a>         <span class="keyword">volatile</span> <span class="keywordtype">int</span>                    <a class="code" href="struct_s_file_op__t.html#5d5cf61968a0cb6006012635d2754544" title="prefetch retire flag.">pending</a>;                        
<a name="l00080"></a>00080 } <a class="code" href="struct_s_file_op__t.html">SFileOp</a>;
<a name="l00081"></a>00081 
<a name="l00082"></a><a class="code" href="struct_s_drive__t.html">00082</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_s_drive__t.html">SDrive_t</a>
<a name="l00083"></a>00083 {
<a name="l00084"></a><a class="code" href="struct_s_drive__t.html#87d7bbf6cb8757f07cdeba13f05cf087">00084</a>         <a class="code" href="wglext_8h.html#a1efb7b85228601549d183556de19dfc">HANDLE</a>                                  <a class="code" href="struct_s_drive__t.html#87d7bbf6cb8757f07cdeba13f05cf087">handle</a>;                         
<a name="l00085"></a><a class="code" href="struct_s_drive__t.html#c7f17137b18a64a3729c24790f263eb9">00085</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    <a class="code" href="struct_s_drive__t.html#c7f17137b18a64a3729c24790f263eb9" title="handle to the drive.">type</a>;                           
<a name="l00086"></a><a class="code" href="struct_s_drive__t.html#6ce4b195fff6401ff3c0e0a14135ded0">00086</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    <a class="code" href="struct_s_drive__t.html#6ce4b195fff6401ff3c0e0a14135ded0" title="CD-ROM, DVD-ROM, HDD, SSD, unknown.">bufferSize</a>;                     
<a name="l00087"></a><a class="code" href="struct_s_drive__t.html#82bfb5892551f2b4ae7d1bfea9fd16bb">00087</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    <a class="code" href="struct_s_drive__t.html#82bfb5892551f2b4ae7d1bfea9fd16bb" title="size of the drive&amp;#39;s cache in bytes.">maxLASize</a>;                      
<a name="l00088"></a><a class="code" href="struct_s_drive__t.html#9751e7f3772821f7eb220fd9f36475e5">00088</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    <a class="code" href="struct_s_drive__t.html#9751e7f3772821f7eb220fd9f36475e5" title="maximum size of a look-ahead read.">maxLACount</a>;                     
<a name="l00089"></a><a class="code" href="struct_s_drive__t.html#53e9e2a8c991d51eb458b07fb96b4620">00089</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    <a class="code" href="struct_s_drive__t.html#53e9e2a8c991d51eb458b07fb96b4620" title="maximum number of reads to look-ahead.">maxSeekBack</a>;            
<a name="l00090"></a><a class="code" href="struct_s_drive__t.html#c54a18e038048b9de16430fdcaa62019">00090</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    <a class="code" href="struct_s_drive__t.html#c54a18e038048b9de16430fdcaa62019" title="maximum number of bytes to read-back.">bytesPerSector</a>;         
<a name="l00091"></a><a class="code" href="struct_s_drive__t.html#840f05d50889266ea6de3979fa0425be">00091</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    <a class="code" href="struct_s_drive__t.html#840f05d50889266ea6de3979fa0425be" title="number of bytes per sector.">sectorsPerCluster</a>;      
<a name="l00092"></a><a class="code" href="struct_s_drive__t.html#a294ea64310e043f9891336769bdbfa6">00092</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    <a class="code" href="struct_s_drive__t.html#a294ea64310e043f9891336769bdbfa6" title="number of sectors per cluster.">bytesPerCluster</a>;        
<a name="l00093"></a>00093 } <a class="code" href="struct_s_drive__t.html">SDrive</a>;
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 <span class="comment">//==========================================================</span>
<a name="l00097"></a>00097 <span class="comment"></span><span class="comment">//==========================================================</span>
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 <span class="keywordtype">void</span>* ( *FSmalloc )( <span class="keywordtype">size_t</span> <a class="code" href="glext_8h.html#3d1e3edfcf61ca2d831883e1afbad89e">size</a> ) = malloc;
<a name="l00100"></a>00100 <a class="code" href="_g_l_u_8h.html#d1bb4b2dc4d2c8b7423c4c9afbf2b484">void</a> ( *<a class="code" href="_f_s_disk_serv___w32_8cpp.html#87b9c234664a4d2cfabf2071df203fa6">FSfree</a> )( <span class="keywordtype">void</span>* mem ) = free;
<a name="l00101"></a>00101 TCHAR* <a class="code" href="_f_s_disk_serv___w32_8cpp.html#10cc1bec4052cb5632c89bc9b1b6e633" title="File local functions.">ConvertString</a>( <span class="keyword">const</span> <a class="code" href="filesystem__afx_8h.html#08b81c947811e6def5d8994fd4d76481">FSchar</a>* <span class="keywordtype">string</span> );
<a name="l00102"></a>00102 <span class="keywordtype">void</span> <a class="code" href="_f_s_disk_serv___w32_8cpp.html#cef30d4a2e6bb61af204268fb375313f">FreeString</a>( TCHAR* <span class="keywordtype">string</span> );
<a name="l00103"></a>00103 
<a name="l00104"></a>00104 <span class="comment">//==========================================================</span>
<a name="l00106"></a>00106 <span class="comment"></span><span class="comment">//==========================================================</span>
<a name="l00107"></a>00107 
<a name="l00108"></a>00108 <span class="keyword">static</span> <span class="keyword">volatile</span> <a class="code" href="struct_s_file__t.html" title="internal structures.">SFile</a>* <span class="keyword">volatile</span> _freeList = 0;
<a name="l00109"></a>00109 <span class="keyword">static</span> <span class="keyword">volatile</span> <a class="code" href="struct_s_file__t.html" title="internal structures.">SFile</a>* <span class="keyword">volatile</span> _blocks[ <a class="code" href="_f_s_disk_serv___w32_8cpp.html#f4832b48e562107b481016b88342a01a">MAX_BLOCK_COUNT</a> ];
<a name="l00110"></a>00110 <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keywordtype">int</span> _freeListGate = 0;
<a name="l00111"></a>00111 <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keywordtype">int</span> _freeRegistered = 0;
<a name="l00112"></a>00112 
<a name="l00113"></a>00113 <span class="comment">//==========================================================</span>
<a name="l00115"></a>00115 <span class="comment"></span><span class="comment">//==========================================================</span>
<a name="l00116"></a>00116 
<a name="l00117"></a>00117 <span class="keyword">static</span> <span class="keyword">volatile</span> <a class="code" href="struct_s_drive__t.html">SDrive</a>* _drives[ <a class="code" href="_f_s_disk_serv___w32_8cpp.html#9d1051fc423c95127cfd80141482f402">MAX_DRIVE_COUNT</a> ];
<a name="l00118"></a>00118 <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keywordtype">int</span> _driveLock = 0;
<a name="l00119"></a>00119 
<a name="l00120"></a>00120 <span class="comment">//==========================================================</span>
<a name="l00122"></a>00122 <span class="comment"></span><span class="comment">//==========================================================</span>
<a name="l00123"></a>00123 
<a name="l00125"></a>00125 <span class="keyword">static</span> <span class="keywordtype">void</span> Start();
<a name="l00126"></a>00126 <span class="keyword">static</span> <span class="keywordtype">void</span> Stop();
<a name="l00127"></a>00127 <span class="keyword">static</span> <span class="keywordtype">void</span> InitDrive( <span class="keywordtype">char</span> letter );
<a name="l00128"></a>00128 <span class="keyword">static</span> <span class="keywordtype">int</span> GetDriveIndex( <span class="keywordtype">char</span> letter );
<a name="l00129"></a>00129 <span class="keyword">static</span> <span class="keywordtype">void</span> FlushDriveQueue( <span class="keywordtype">int</span> <a class="code" href="glext_8h.html#57f14e05b1900f16a2da82ade47d0c6d">index</a> );
<a name="l00130"></a>00130 <span class="keyword">static</span> <span class="keywordtype">void</span> ThreadMain( <span class="keywordtype">void</span>* );
<a name="l00131"></a>00131 <span class="keyword">static</span> <span class="keywordtype">void</span> CALLBACK IOComplete( DWORD dwErrorCode, DWORD dwBytesTransfered, LPOVERLAPPED overlapped );
<a name="l00132"></a>00132 <span class="keyword">static</span> <a class="code" href="filesystem__afx_8h.html#2dfedf2033eee861d23c808f79ed5837">FSsize</a> CalcPhysAddr( <a class="code" href="struct_s_file_op__t.html">SFileOp</a>* op );
<a name="l00133"></a>00133 
<a name="l00135"></a>00135 <span class="keyword">static</span> uintptr_t _workerThread = 0;
<a name="l00136"></a>00136 
<a name="l00137"></a>00137 <span class="comment">//==========================================================</span>
<a name="l00139"></a>00139 <span class="comment"></span><span class="comment">//==========================================================</span>
<a name="l00140"></a>00140 
<a name="l00142"></a>00142 <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keywordtype">int</span> _threadExit = 0;
<a name="l00143"></a>00143 <span class="keyword">static</span> <a class="code" href="struct_s_file_op__t.html">SFileOp</a> _ops[ <a class="code" href="_f_s_disk_serv___w32_8cpp.html#9d1051fc423c95127cfd80141482f402">MAX_DRIVE_COUNT</a> ][ <a class="code" href="_f_s_disk_serv___w32_8cpp.html#ecc4c5fadbda3d12a5a810f93cf2fe43">MAX_PENDING_IO</a> ];
<a name="l00144"></a>00144 <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keywordtype">int</span> _queuePushLock[ <a class="code" href="_f_s_disk_serv___w32_8cpp.html#9d1051fc423c95127cfd80141482f402">MAX_DRIVE_COUNT</a> ];
<a name="l00145"></a>00145 <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keywordtype">int</span> _queuePushIdx[ <a class="code" href="_f_s_disk_serv___w32_8cpp.html#9d1051fc423c95127cfd80141482f402">MAX_DRIVE_COUNT</a> ];
<a name="l00146"></a>00146 <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keywordtype">int</span> _queuePopIdx[ <a class="code" href="_f_s_disk_serv___w32_8cpp.html#9d1051fc423c95127cfd80141482f402">MAX_DRIVE_COUNT</a> ];
<a name="l00147"></a>00147 
<a name="l00148"></a>00148 
<a name="l00149"></a>00149 <span class="comment">//**********************************************************</span>
<a name="l00151"></a>00151 <span class="comment"></span><span class="comment">//**********************************************************</span>
<a name="l00152"></a>00152 
<a name="l00153"></a>00153 <span class="comment">//----------------------------------------------------------</span>
<a name="l00154"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#639bb9787444e8c425eec0256793d968">00154</a> <span class="keywordtype">void</span> <a class="code" href="_f_s_disk_serv_8h.html#639bb9787444e8c425eec0256793d968" title="File management functions.">FS_ScanDrives</a>()
<a name="l00155"></a>00155 {
<a name="l00157"></a>00157         DWORD bitMask = 1;
<a name="l00158"></a>00158         DWORD driveMask = GetLogicalDrives();
<a name="l00159"></a>00159         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = <span class="charliteral">'A'</span>; i &lt; <span class="charliteral">'Z'</span>; ++i, bitMask += bitMask )
<a name="l00160"></a>00160         {
<a name="l00161"></a>00161                 <span class="keywordflow">if</span> ( ( driveMask &amp; bitMask ) != 0 )
<a name="l00162"></a>00162                         InitDrive( i );
<a name="l00163"></a>00163         }
<a name="l00164"></a>00164 }
<a name="l00165"></a>00165 
<a name="l00166"></a>00166 <span class="comment">//----------------------------------------------------------</span>
<a name="l00167"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#64815f6582883caa8b5e134620e36d47">00167</a> <span class="keywordtype">void</span>* <a class="code" href="_f_s_disk_serv_8h.html#64815f6582883caa8b5e134620e36d47">FS_OpenFile</a>( <span class="keyword">const</span> <a class="code" href="filesystem__afx_8h.html#08b81c947811e6def5d8994fd4d76481">FSchar</a>* <a class="code" href="glext_8h.html#f7477b8725fcf509c9623f64b9d09164">name</a>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="_u_t_message_8h.html#0a3c0b351ab09281b662a9ff4f900a53">flags</a> )
<a name="l00168"></a>00168 {
<a name="l00171"></a>00171         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> win32Flags = 0;
<a name="l00172"></a>00172         <span class="keywordflow">if</span> ( flags &amp; <a class="code" href="_f_s_disk_serv_8h.html#60eb9079b948d946a7cd7eb3741741b3">FS_FILE_FLAG_READ</a> )
<a name="l00173"></a>00173                 win32Flags |= GENERIC_READ;
<a name="l00174"></a>00174         <span class="keywordflow">if</span> ( flags &amp; <a class="code" href="_f_s_disk_serv_8h.html#1ca62fb541490d8da3caa283ef137664">FS_FILE_FLAG_WRITE</a> )
<a name="l00175"></a>00175                 win32Flags |= GENERIC_WRITE;
<a name="l00176"></a>00176 
<a name="l00178"></a>00178         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> win32CreationMode = OPEN_EXISTING;
<a name="l00179"></a>00179         <span class="keywordflow">if</span> ( flags &amp; <a class="code" href="_f_s_disk_serv_8h.html#2814b42b6973facb8a5c61d548a0f7df" title="Purpose: To provide a platform independent wrapper around a disk.">FS_FILE_FLAG_CREATE_ALWAYS</a> )
<a name="l00180"></a>00180                 win32CreationMode = CREATE_ALWAYS;
<a name="l00181"></a>00181         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( flags &amp; <a class="code" href="_f_s_disk_serv_8h.html#b66b8115f52b2492ba9bc3362a9e9da1">FS_FILE_FLAG_OPEN_ALWAYS</a> )
<a name="l00182"></a>00182                 win32CreationMode = OPEN_ALWAYS;
<a name="l00183"></a>00183 
<a name="l00185"></a>00185         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> win32AttrFlags = FILE_FLAG_OVERLAPPED;
<a name="l00186"></a>00186         <span class="keywordflow">if</span> ( flags &amp; <a class="code" href="_f_s_disk_serv_8h.html#0f6bbf8731c9cf9859810948ea751be8">FS_FILE_FLAG_USE_DMA</a> )
<a name="l00187"></a>00187                 win32AttrFlags |= FILE_FLAG_NO_BUFFERING;
<a name="l00188"></a>00188 
<a name="l00190"></a>00190         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> win32ShareMode = FILE_SHARE_READ;
<a name="l00191"></a>00191         <span class="keywordflow">if</span> ( !( flags &amp; FS_FILE_FLAG_WRITE ) )
<a name="l00192"></a>00192                 win32ShareMode |= FILE_SHARE_WRITE;
<a name="l00193"></a>00193 
<a name="l00195"></a>00195         TCHAR* ucsName = <a class="code" href="_f_s_disk_serv___w32_8cpp.html#10cc1bec4052cb5632c89bc9b1b6e633" title="File local functions.">ConvertString</a>( name );
<a name="l00196"></a>00196 
<a name="l00199"></a>00199         <a class="code" href="wglext_8h.html#a1efb7b85228601549d183556de19dfc">HANDLE</a> handle = CreateFile( ucsName, win32Flags, win32ShareMode, NULL, win32CreationMode, win32AttrFlags, NULL );
<a name="l00200"></a>00200         <span class="keywordflow">if</span> ( handle == INVALID_HANDLE_VALUE )
<a name="l00201"></a>00201         {
<a name="l00202"></a>00202                 <a class="code" href="_f_s_disk_serv___w32_8cpp.html#cef30d4a2e6bb61af204268fb375313f">FreeString</a>( ucsName );
<a name="l00203"></a>00203                 <span class="keywordflow">return</span> 0;
<a name="l00204"></a>00204         }
<a name="l00205"></a>00205 
<a name="l00207"></a>00207         DWORD bufferLen = 1;
<a name="l00208"></a>00208         TCHAR temp = 0;
<a name="l00209"></a>00209         bufferLen = GetFullPathName( ucsName, bufferLen, &amp;temp, NULL ) + 1;
<a name="l00210"></a>00210 
<a name="l00212"></a>00212         TCHAR* fullPath = ( TCHAR* )<a class="code" href="_f_s_disk_serv___w32_8cpp.html#552500941af2ffc7f64f1e8a0fe00a0c" title="Memory management routines.">FSmalloc</a>( bufferLen * <span class="keyword">sizeof</span>( TCHAR ) );
<a name="l00213"></a>00213         DWORD result = GetFullPathName( ucsName, bufferLen, fullPath, NULL );
<a name="l00214"></a>00214 
<a name="l00216"></a>00216         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> driveIndex = <a class="code" href="_f_s_disk_serv___w32_8cpp.html#9d1051fc423c95127cfd80141482f402">MAX_DRIVE_COUNT</a> - 1;
<a name="l00217"></a>00217         <span class="keywordflow">if</span> ( result != 0 &amp;&amp; result &lt;= bufferLen )
<a name="l00218"></a>00218         {
<a name="l00220"></a>00220                 <span class="keywordflow">if</span> ( fullPath[ 1 ] == _T( <span class="charliteral">':'</span> ) )
<a name="l00221"></a>00221                 {
<a name="l00222"></a>00222                         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> t0 = ( fullPath[ 0 ] - _T( <span class="charliteral">'A'</span> ) );
<a name="l00223"></a>00223                         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> t1 = ( fullPath[ 0 ] - _T( <span class="charliteral">'a'</span> ) );
<a name="l00224"></a>00224                         driveIndex = <a class="code" href="_u_t_x_8cpp.html#3f06f0e9f7beb8214afeea0b18ef8377">min</a>( t0, t1 );
<a name="l00225"></a>00225                 }
<a name="l00226"></a>00226         }
<a name="l00227"></a>00227 
<a name="l00229"></a>00229         <a class="code" href="_f_s_disk_serv___w32_8cpp.html#87b9c234664a4d2cfabf2071df203fa6">FSfree</a>( fullPath );
<a name="l00230"></a>00230 
<a name="l00232"></a>00232         <a class="code" href="_f_s_disk_serv___w32_8cpp.html#cef30d4a2e6bb61af204268fb375313f">FreeString</a>( ucsName );
<a name="l00233"></a>00233 
<a name="l00235"></a>00235         <span class="keywordflow">if</span> ( flags &amp; FS_FILE_FLAG_USE_DMA )
<a name="l00236"></a>00236                 FlushFileBuffers( handle );
<a name="l00237"></a>00237 
<a name="l00241"></a>00241         <span class="keywordflow">while</span> ( <a class="code" href="filesystem__afx_8h.html#942a7d92d20632b09a881e60b3b0da51" title="function prototypes to ease the reading of this file.">_FS_Swap</a>( &amp;_freeListGate, 1 ) )
<a name="l00242"></a>00242                 _FS_Pause();
<a name="l00243"></a>00243 
<a name="l00245"></a>00245         <span class="keywordflow">if</span> ( !_freeList )
<a name="l00246"></a>00246         {
<a name="l00247"></a>00247                 <span class="keywordflow">if</span> ( !_freeRegistered )
<a name="l00248"></a>00248                         Start();
<a name="l00249"></a>00249 
<a name="l00251"></a>00251                 <span class="keywordflow">if</span> ( _freeRegistered == <a class="code" href="_f_s_disk_serv___w32_8cpp.html#f4832b48e562107b481016b88342a01a">MAX_BLOCK_COUNT</a> )
<a name="l00252"></a>00252                         <span class="keywordflow">return</span> 0;
<a name="l00253"></a>00253 
<a name="l00259"></a>00259                 <a class="code" href="struct_s_file__t.html" title="internal structures.">SFile</a>* memory = ( <a class="code" href="struct_s_file__t.html" title="internal structures.">SFile</a>* )<a class="code" href="filesystem__afx_8h.html#d0c6c8d0a75e52a9ebc827fd45e95898">_FS_AlignedAlloc</a>( <a class="code" href="_f_s_disk_serv___w32_8cpp.html#1bd31ca46edf8a2f66c3890a2dbbe564" title="file header.">BLOCKS_PER_ALLOCATION</a> * <span class="keyword">sizeof</span>( <a class="code" href="struct_s_file__t.html" title="internal structures.">SFile</a> ), 32 );
<a name="l00260"></a>00260 
<a name="l00262"></a>00262                 <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; <a class="code" href="_f_s_disk_serv___w32_8cpp.html#1bd31ca46edf8a2f66c3890a2dbbe564" title="file header.">BLOCKS_PER_ALLOCATION</a>; ++i )
<a name="l00263"></a>00263                         memory[ i - 1 ].nextFree = memory + i;
<a name="l00264"></a>00264 
<a name="l00266"></a>00266                 memory[ BLOCKS_PER_ALLOCATION - 1 ].<a class="code" href="struct_s_file__t.html#efe9a20ae13e8a4b3d92770f7f042493" title="start on the hard-drive.">nextFree</a> = 0;
<a name="l00267"></a>00267                 _freeList = memory;
<a name="l00268"></a>00268 
<a name="l00271"></a>00271                 _blocks[ _freeRegistered ] = _freeList;
<a name="l00272"></a>00272                 _FS_Increment( &amp;_freeRegistered );
<a name="l00273"></a>00273         }
<a name="l00274"></a>00274 
<a name="l00276"></a>00276         <span class="keyword">volatile</span> <a class="code" href="struct_s_file__t.html" title="internal structures.">SFile</a>* fileEntry = _freeList;
<a name="l00277"></a>00277         _freeList = _freeList-&gt;<a class="code" href="struct_s_file__t.html#efe9a20ae13e8a4b3d92770f7f042493" title="start on the hard-drive.">nextFree</a>;
<a name="l00278"></a>00278 
<a name="l00280"></a>00280         <a class="code" href="filesystem__afx_8h.html#942a7d92d20632b09a881e60b3b0da51" title="function prototypes to ease the reading of this file.">_FS_Swap</a>( &amp;_freeListGate, 0 );
<a name="l00281"></a>00281 
<a name="l00283"></a>00283         fileEntry-&gt;<a class="code" href="struct_s_file__t.html#9c5b15b8c07aca9928c6a347e765d60f">handle</a> = handle;
<a name="l00284"></a>00284         fileEntry-&gt;<a class="code" href="struct_s_file__t.html#4dafbf10076baf07fe478e79a33fdc8b" title="Win32 file handle.">flags</a> = flags;
<a name="l00285"></a>00285         fileEntry-&gt;<a class="code" href="struct_s_file__t.html#21b0d1399a43df9577404c7b2004c5b4" title="creation flags.">drive</a> = driveIndex;
<a name="l00286"></a>00286         fileEntry-&gt;<a class="code" href="struct_s_file__t.html#3ec63209feb76e69e0d6be30d3cae074" title="the drive on which the file is located.">offset</a> = 0;
<a name="l00287"></a>00287         fileEntry-&gt;<a class="code" href="struct_s_file__t.html#28381f30fa5e5f18fd8c6e6d7f2a76f3" title="absolute file offset.">physAddr</a> = 0;
<a name="l00288"></a>00288         fileEntry-&gt;<a class="code" href="struct_s_file__t.html#efe9a20ae13e8a4b3d92770f7f042493" title="start on the hard-drive.">nextFree</a> = 0;
<a name="l00289"></a>00289 
<a name="l00291"></a>00291         STARTING_VCN_INPUT_BUFFER inputVCN;
<a name="l00292"></a>00292         inputVCN.StartingVcn.HighPart = 0;
<a name="l00293"></a>00293         inputVCN.StartingVcn.LowPart = 0;
<a name="l00294"></a>00294         RETRIEVAL_POINTERS_BUFFER fileAddr;
<a name="l00295"></a>00295         DWORD bytesReturned = 0;
<a name="l00296"></a>00296         OVERLAPPED overlapped;
<a name="l00297"></a>00297         overlapped.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
<a name="l00298"></a>00298         overlapped.Internal = 0;
<a name="l00299"></a>00299         overlapped.InternalHigh = 0;
<a name="l00300"></a>00300         overlapped.Offset = 0;
<a name="l00301"></a>00301         overlapped.OffsetHigh = 0;
<a name="l00302"></a>00302         <a class="code" href="wglext_8h.html#05538ca0e53ef21cb679e6de0fef7f8e">BOOL</a> ret = DeviceIoControl( handle, FSCTL_GET_RETRIEVAL_POINTERS, &amp;inputVCN, <span class="keyword">sizeof</span>( inputVCN ),
<a name="l00303"></a>00303                 &amp;fileAddr, <span class="keyword">sizeof</span>( fileAddr ), &amp;bytesReturned, &amp;overlapped );
<a name="l00304"></a>00304 
<a name="l00309"></a>00309         DWORD error = GetLastError();
<a name="l00310"></a>00310         <span class="keywordflow">if</span> ( ret || error == ERROR_MORE_DATA )
<a name="l00311"></a>00311         {
<a name="l00313"></a>00313                 WaitForSingleObject( overlapped.hEvent, INFINITE );
<a name="l00314"></a>00314 
<a name="l00316"></a>00316                 fileEntry-&gt;<a class="code" href="struct_s_file__t.html#28381f30fa5e5f18fd8c6e6d7f2a76f3" title="absolute file offset.">physAddr</a> = <a class="code" href="filesystem__afx_8h.html#fd795f2042c2f66113f5a2bf2ddadea9">MAKE_FSIZE</a>( fileAddr.Extents[ 0 ].Lcn.LowPart, fileAddr.Extents[ 0 ].Lcn.HighPart );
<a name="l00317"></a>00317                 fileEntry-&gt;<a class="code" href="struct_s_file__t.html#28381f30fa5e5f18fd8c6e6d7f2a76f3" title="absolute file offset.">physAddr</a> *= _drives[ driveIndex ]-&gt;<a class="code" href="struct_s_drive__t.html#a294ea64310e043f9891336769bdbfa6" title="number of sectors per cluster.">bytesPerCluster</a>;
<a name="l00318"></a>00318         }
<a name="l00319"></a>00319 
<a name="l00321"></a>00321         CloseHandle( overlapped.hEvent );
<a name="l00322"></a>00322 
<a name="l00324"></a>00324         <span class="keywordflow">return</span> ( <span class="keywordtype">void</span>* )fileEntry;
<a name="l00325"></a>00325 }
<a name="l00326"></a>00326 
<a name="l00327"></a>00327 <span class="comment">//----------------------------------------------------------</span>
<a name="l00328"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#29e88ae79f07f5d597e6729a4a66a76e">00328</a> <span class="keywordtype">void</span> <a class="code" href="_f_s_disk_serv_8h.html#5a68c779c26cd02b2f7b17851f363683">FS_CloseFile</a>( <span class="keywordtype">void</span>* fileHandle )
<a name="l00329"></a>00329 {
<a name="l00331"></a>00331         <span class="keyword">volatile</span> <a class="code" href="struct_s_file__t.html" title="internal structures.">SFile</a>* fileEntry = ( <span class="keyword">volatile</span> <a class="code" href="struct_s_file__t.html" title="internal structures.">SFile</a>* )fileHandle;
<a name="l00332"></a>00332 
<a name="l00335"></a>00335         <a class="code" href="wglext_8h.html#a1efb7b85228601549d183556de19dfc">HANDLE</a> handle = ( <a class="code" href="wglext_8h.html#a1efb7b85228601549d183556de19dfc">HANDLE</a> )_FS_INT_TO_PTR(
<a name="l00336"></a>00336                 <a class="code" href="filesystem__afx_8h.html#942a7d92d20632b09a881e60b3b0da51" title="function prototypes to ease the reading of this file.">_FS_Swap</a>( ( <span class="keyword">volatile</span> <span class="keywordtype">int</span>* )( &amp;fileEntry-&gt;<a class="code" href="struct_s_file__t.html#9c5b15b8c07aca9928c6a347e765d60f">handle</a> ), _FS_PTR_TO_INT( INVALID_HANDLE_VALUE ) )
<a name="l00337"></a>00337                 );
<a name="l00338"></a>00338         <span class="keywordflow">if</span> ( handle == INVALID_HANDLE_VALUE )
<a name="l00339"></a>00339                 <span class="keywordflow">return</span>;
<a name="l00340"></a>00340 
<a name="l00343"></a>00343         FlushDriveQueue( fileEntry-&gt;<a class="code" href="struct_s_file__t.html#21b0d1399a43df9577404c7b2004c5b4" title="creation flags.">drive</a> );
<a name="l00344"></a>00344 
<a name="l00346"></a>00346         CloseHandle( handle );
<a name="l00347"></a>00347 
<a name="l00349"></a>00349         <span class="keywordflow">while</span> ( <a class="code" href="filesystem__afx_8h.html#942a7d92d20632b09a881e60b3b0da51" title="function prototypes to ease the reading of this file.">_FS_Swap</a>( &amp;_freeListGate, 1 ) )
<a name="l00350"></a>00350                 _FS_Pause();
<a name="l00351"></a>00351         fileEntry-&gt;<a class="code" href="struct_s_file__t.html#efe9a20ae13e8a4b3d92770f7f042493" title="start on the hard-drive.">nextFree</a> = _freeList;
<a name="l00352"></a>00352         _freeList = fileEntry;
<a name="l00353"></a>00353         <a class="code" href="filesystem__afx_8h.html#942a7d92d20632b09a881e60b3b0da51" title="function prototypes to ease the reading of this file.">_FS_Swap</a>( &amp;_freeListGate, 0 );
<a name="l00354"></a>00354 }
<a name="l00355"></a>00355 
<a name="l00356"></a>00356 <span class="comment">//----------------------------------------------------------</span>
<a name="l00357"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#c13642cf33b2e0afa23742d1d8f9d8dc">00357</a> <a class="code" href="filesystem__afx_8h.html#2dfedf2033eee861d23c808f79ed5837">FSsize</a> <a class="code" href="_f_s_disk_serv_8h.html#06899e7652bf3e71c758ff036404d635">FS_GetFileSize</a>( <span class="keywordtype">void</span>* fileHandle )
<a name="l00358"></a>00358 {
<a name="l00360"></a>00360         <span class="keyword">volatile</span> <a class="code" href="struct_s_file__t.html" title="internal structures.">SFile</a>* fileEntry = ( <span class="keyword">volatile</span> <a class="code" href="struct_s_file__t.html" title="internal structures.">SFile</a>* )fileHandle;
<a name="l00361"></a>00361 
<a name="l00364"></a>00364         FlushDriveQueue( fileEntry-&gt;<a class="code" href="struct_s_file__t.html#21b0d1399a43df9577404c7b2004c5b4" title="creation flags.">drive</a> );
<a name="l00365"></a>00365 
<a name="l00367"></a>00367         LARGE_INTEGER <a class="code" href="glext_8h.html#3d1e3edfcf61ca2d831883e1afbad89e">size</a>;
<a name="l00368"></a>00368         GetFileSizeEx( fileEntry-&gt;<a class="code" href="struct_s_file__t.html#9c5b15b8c07aca9928c6a347e765d60f">handle</a>, &amp;size );
<a name="l00369"></a>00369 
<a name="l00371"></a>00371         <span class="keywordflow">return</span> <a class="code" href="filesystem__afx_8h.html#fd795f2042c2f66113f5a2bf2ddadea9">MAKE_FSIZE</a>( size.LowPart, size.HighPart );
<a name="l00372"></a>00372 }
<a name="l00373"></a>00373 
<a name="l00374"></a>00374 <span class="comment">//----------------------------------------------------------</span>
<a name="l00375"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#9e21afbbba101c7dc7be9a43fd5291f6">00375</a> <span class="keywordtype">void</span> <a class="code" href="_f_s_disk_serv_8h.html#9e21afbbba101c7dc7be9a43fd5291f6">FS_ReadFile</a>( <a class="code" href="struct_s_f_s_file_read_buffer__t.html" title="File structures.">SFSFileReadBuffer</a>* <a class="code" href="glext_8h.html#92034251bfd455d524a9b5610cddba00">dst</a>, <span class="keywordtype">void</span>* file, <a class="code" href="filesystem__afx_8h.html#2dfedf2033eee861d23c808f79ed5837">FSsize</a> <a class="code" href="glext_8h.html#a782f3aea23e3c30029c811241dc2c82">offset</a>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="glext_8h.html#3d1e3edfcf61ca2d831883e1afbad89e">size</a> )
<a name="l00376"></a>00376 {
<a name="l00378"></a>00378         <a class="code" href="struct_s_file__t.html" title="internal structures.">SFile</a>* fileEntry = ( <a class="code" href="struct_s_file__t.html" title="internal structures.">SFile</a>* )file;
<a name="l00379"></a>00379         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> drive = fileEntry-&gt;<a class="code" href="struct_s_file__t.html#21b0d1399a43df9577404c7b2004c5b4" title="creation flags.">drive</a>;
<a name="l00380"></a>00380 
<a name="l00382"></a>00382         <span class="keywordflow">while</span> ( <a class="code" href="filesystem__afx_8h.html#942a7d92d20632b09a881e60b3b0da51" title="function prototypes to ease the reading of this file.">_FS_Swap</a>( _queuePushLock + drive, 1 ) != 0 )
<a name="l00383"></a>00383                 _FS_Pause();
<a name="l00384"></a>00384 
<a name="l00387"></a>00387         <span class="keywordflow">while</span> ( ( _queuePushIdx[ drive ] - _queuePopIdx[ drive ] ) == <a class="code" href="_f_s_disk_serv___w32_8cpp.html#ecc4c5fadbda3d12a5a810f93cf2fe43">MAX_PENDING_IO</a> )
<a name="l00388"></a>00388                 _FS_Pause();
<a name="l00389"></a>00389 
<a name="l00391"></a>00391         <span class="keyword">volatile</span> <a class="code" href="struct_s_file_op__t.html">SFileOp</a>* curOp = _ops[ drive ] + _queuePushIdx[ drive ] % <a class="code" href="_f_s_disk_serv___w32_8cpp.html#ecc4c5fadbda3d12a5a810f93cf2fe43">MAX_PENDING_IO</a>;
<a name="l00392"></a>00392 
<a name="l00394"></a>00394         <span class="keywordflow">while</span> ( <a class="code" href="filesystem__afx_8h.html#942a7d92d20632b09a881e60b3b0da51" title="function prototypes to ease the reading of this file.">_FS_Swap</a>( &amp;curOp-&gt;<a class="code" href="struct_s_file_op__t.html#5d5cf61968a0cb6006012635d2754544" title="prefetch retire flag.">pending</a>, 1 ) != 0 )
<a name="l00395"></a>00395                 _FS_Pause();
<a name="l00396"></a>00396 
<a name="l00398"></a>00398         curOp-&gt;<a class="code" href="struct_s_file_op__t.html#a85b29f1d72b6b477e9e4ba93f18be1c">readBuffer</a> = dst;
<a name="l00399"></a>00399         curOp-&gt;<a class="code" href="struct_s_file_op__t.html#35a76a584a5395b66dc709e5a81a690a" title="non-zero for a read event.">writeBuffer</a> = 0;
<a name="l00400"></a>00400         curOp-&gt;<a class="code" href="struct_s_file_op__t.html#3d23fc9294b4099d03479ecc39867c5d" title="file pointer.">size</a> = size;
<a name="l00401"></a>00401         curOp-&gt;<a class="code" href="struct_s_file_op__t.html#d11881794d5507b1eee0c41a840b7062" title="non-zero for a write event.">file</a> = fileEntry;
<a name="l00402"></a>00402         curOp-&gt;<a class="code" href="struct_s_file_op__t.html#b7c0b908f7ae23db0ed6963eb79335e8" title="amount of data to read/write.">retired</a> = 0;
<a name="l00403"></a>00403         curOp-&gt;<a class="code" href="struct_s_file_op__t.html#7580e2d7725d9e62b6f01af716882b5a">overlapped</a>.Internal = 0;
<a name="l00404"></a>00404         curOp-&gt;<a class="code" href="struct_s_file_op__t.html#7580e2d7725d9e62b6f01af716882b5a">overlapped</a>.InternalHigh = 0;
<a name="l00405"></a>00405         curOp-&gt;<a class="code" href="struct_s_file_op__t.html#7580e2d7725d9e62b6f01af716882b5a">overlapped</a>.Offset = ( DWORD )offset;
<a name="l00406"></a>00406         curOp-&gt;<a class="code" href="struct_s_file_op__t.html#7580e2d7725d9e62b6f01af716882b5a">overlapped</a>.OffsetHigh = ( DWORD )( offset &gt;&gt; 32 );
<a name="l00407"></a>00407         curOp-&gt;<a class="code" href="struct_s_file_op__t.html#7580e2d7725d9e62b6f01af716882b5a">overlapped</a>.hEvent = 0;
<a name="l00408"></a>00408 
<a name="l00410"></a>00410         _FS_Increment( _queuePushIdx + drive );
<a name="l00411"></a>00411 
<a name="l00413"></a>00413         <a class="code" href="filesystem__afx_8h.html#942a7d92d20632b09a881e60b3b0da51" title="function prototypes to ease the reading of this file.">_FS_Swap</a>( _queuePushLock + drive, 0 );
<a name="l00414"></a>00414 }
<a name="l00415"></a>00415 
<a name="l00416"></a>00416 <span class="comment">//----------------------------------------------------------</span>
<a name="l00417"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#c7abe5c9b19a9611de00573a09fd3a61">00417</a> <span class="keywordtype">void</span> <a class="code" href="_f_s_disk_serv_8h.html#c7abe5c9b19a9611de00573a09fd3a61">FS_WriteFile</a>( <span class="keywordtype">void</span>* file, <a class="code" href="filesystem__afx_8h.html#2dfedf2033eee861d23c808f79ed5837">FSsize</a> <a class="code" href="glext_8h.html#a782f3aea23e3c30029c811241dc2c82">offset</a>, <a class="code" href="struct_s_f_s_file_write_buffer__t.html">SFSFileWriteBuffer</a>* <a class="code" href="glext_8h.html#72e0fdf0f845ded60b1fada9e9195cd7">src</a>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="glext_8h.html#3d1e3edfcf61ca2d831883e1afbad89e">size</a> )
<a name="l00418"></a>00418 {
<a name="l00420"></a>00420         <a class="code" href="struct_s_file__t.html" title="internal structures.">SFile</a>* fileEntry = ( <a class="code" href="struct_s_file__t.html" title="internal structures.">SFile</a>* )file;
<a name="l00421"></a>00421         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> drive = fileEntry-&gt;<a class="code" href="struct_s_file__t.html#21b0d1399a43df9577404c7b2004c5b4" title="creation flags.">drive</a>;
<a name="l00422"></a>00422 
<a name="l00424"></a>00424         <span class="keywordflow">while</span> ( <a class="code" href="filesystem__afx_8h.html#942a7d92d20632b09a881e60b3b0da51" title="function prototypes to ease the reading of this file.">_FS_Swap</a>( _queuePushLock + drive, 1 ) != 0 )
<a name="l00425"></a>00425                 _FS_Pause();
<a name="l00426"></a>00426 
<a name="l00429"></a>00429         <span class="keywordflow">while</span> ( ( _queuePushIdx[ drive ] - _queuePopIdx[ drive ] ) == <a class="code" href="_f_s_disk_serv___w32_8cpp.html#ecc4c5fadbda3d12a5a810f93cf2fe43">MAX_PENDING_IO</a> )
<a name="l00430"></a>00430                 _FS_Pause();
<a name="l00431"></a>00431 
<a name="l00433"></a>00433         <span class="keyword">volatile</span> <a class="code" href="struct_s_file_op__t.html">SFileOp</a>* curOp = _ops[ drive ] + _queuePushIdx[ drive ] % <a class="code" href="_f_s_disk_serv___w32_8cpp.html#ecc4c5fadbda3d12a5a810f93cf2fe43">MAX_PENDING_IO</a>;
<a name="l00434"></a>00434 
<a name="l00436"></a>00436         <span class="keywordflow">while</span> ( <a class="code" href="filesystem__afx_8h.html#942a7d92d20632b09a881e60b3b0da51" title="function prototypes to ease the reading of this file.">_FS_Swap</a>( &amp;curOp-&gt;<a class="code" href="struct_s_file_op__t.html#5d5cf61968a0cb6006012635d2754544" title="prefetch retire flag.">pending</a>, 1 ) != 0 )
<a name="l00437"></a>00437                 _FS_Pause();
<a name="l00438"></a>00438 
<a name="l00440"></a>00440         curOp-&gt;<a class="code" href="struct_s_file_op__t.html#a85b29f1d72b6b477e9e4ba93f18be1c">readBuffer</a> = 0;
<a name="l00441"></a>00441         curOp-&gt;<a class="code" href="struct_s_file_op__t.html#35a76a584a5395b66dc709e5a81a690a" title="non-zero for a read event.">writeBuffer</a> = src;
<a name="l00442"></a>00442         curOp-&gt;<a class="code" href="struct_s_file_op__t.html#3d23fc9294b4099d03479ecc39867c5d" title="file pointer.">size</a> = size;
<a name="l00443"></a>00443         curOp-&gt;<a class="code" href="struct_s_file_op__t.html#d11881794d5507b1eee0c41a840b7062" title="non-zero for a write event.">file</a> = fileEntry;
<a name="l00444"></a>00444         curOp-&gt;<a class="code" href="struct_s_file_op__t.html#b7c0b908f7ae23db0ed6963eb79335e8" title="amount of data to read/write.">retired</a> = 0;
<a name="l00445"></a>00445         curOp-&gt;<a class="code" href="struct_s_file_op__t.html#7580e2d7725d9e62b6f01af716882b5a">overlapped</a>.Internal = 0;
<a name="l00446"></a>00446         curOp-&gt;<a class="code" href="struct_s_file_op__t.html#7580e2d7725d9e62b6f01af716882b5a">overlapped</a>.InternalHigh = 0;
<a name="l00447"></a>00447         curOp-&gt;<a class="code" href="struct_s_file_op__t.html#7580e2d7725d9e62b6f01af716882b5a">overlapped</a>.Offset = ( DWORD )offset;
<a name="l00448"></a>00448         curOp-&gt;<a class="code" href="struct_s_file_op__t.html#7580e2d7725d9e62b6f01af716882b5a">overlapped</a>.OffsetHigh = ( DWORD )( offset &gt;&gt; 32 );
<a name="l00449"></a>00449         curOp-&gt;<a class="code" href="struct_s_file_op__t.html#7580e2d7725d9e62b6f01af716882b5a">overlapped</a>.hEvent = 0;
<a name="l00450"></a>00450 
<a name="l00452"></a>00452         _FS_Increment( _queuePushIdx + drive );
<a name="l00453"></a>00453 
<a name="l00455"></a>00455         <a class="code" href="filesystem__afx_8h.html#942a7d92d20632b09a881e60b3b0da51" title="function prototypes to ease the reading of this file.">_FS_Swap</a>( _queuePushLock + drive, 0 );
<a name="l00456"></a>00456 }
<a name="l00457"></a>00457 
<a name="l00458"></a>00458 <span class="comment">//----------------------------------------------------------</span>
<a name="l00459"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#b8abbd85f1942b0f3dca1793ea4e8978">00459</a> <span class="keywordtype">void</span> <a class="code" href="_f_s_disk_serv_8h.html#b8abbd85f1942b0f3dca1793ea4e8978">FS_Wait</a>( <span class="keyword">volatile</span> <span class="keywordtype">int</span>* gate )
<a name="l00460"></a>00460 {
<a name="l00462"></a>00462         <span class="keywordflow">while</span> ( <a class="code" href="filesystem__afx_8h.html#942a7d92d20632b09a881e60b3b0da51" title="function prototypes to ease the reading of this file.">_FS_Swap</a>( gate, 0 ) == 0 )
<a name="l00463"></a>00463                 _FS_Pause();
<a name="l00464"></a>00464 }
<a name="l00465"></a>00465 
<a name="l00466"></a>00466 <span class="comment">//----------------------------------------------------------</span>
<a name="l00467"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#013362d3615068eee7220194a88a4d73">00467</a> <span class="keywordtype">bool</span> <a class="code" href="_f_s_disk_serv_8h.html#013362d3615068eee7220194a88a4d73" title="waits for and resets the gate&amp;#39;s value.">FS_IsComplete</a>( <span class="keyword">volatile</span> <span class="keywordtype">int</span>* gate )
<a name="l00468"></a>00468 {
<a name="l00470"></a>00470         <span class="keywordflow">return</span> ( <a class="code" href="filesystem__afx_8h.html#942a7d92d20632b09a881e60b3b0da51" title="function prototypes to ease the reading of this file.">_FS_Swap</a>( gate, 0 ) != 0 );
<a name="l00471"></a>00471 }
<a name="l00472"></a>00472 
<a name="l00473"></a>00473 <span class="comment">//----------------------------------------------------------</span>
<a name="l00474"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#34306284dd0c7f5c8f91de947b3e43f1">00474</a> <span class="keywordtype">bool</span> <a class="code" href="_f_s_disk_serv_8h.html#34306284dd0c7f5c8f91de947b3e43f1" title="checks and resets the gate&amp;#39;s value.">FS_IsReadComplete</a>( <a class="code" href="struct_s_f_s_file_read_buffer__t.html" title="File structures.">SFSFileReadBuffer</a>* readBuffer )
<a name="l00475"></a>00475 {
<a name="l00476"></a>00476         <span class="keywordflow">return</span> ( <a class="code" href="_f_s_disk_serv_8h.html#013362d3615068eee7220194a88a4d73" title="waits for and resets the gate&amp;#39;s value.">FS_IsComplete</a>( &amp;readBuffer-&gt;<a class="code" href="struct_s_f_s_file_read_buffer__t.html#87bd7289db7343742a40bdc52f4fff0a">complete</a> ) );
<a name="l00477"></a>00477 }
<a name="l00478"></a>00478 
<a name="l00479"></a>00479 <span class="comment">//----------------------------------------------------------</span>
<a name="l00480"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#da15545e379beea3118877a61f7c4df6">00480</a> <span class="keywordtype">bool</span> <a class="code" href="_f_s_disk_serv_8h.html#da15545e379beea3118877a61f7c4df6">FS_IsWriteComplete</a>( <a class="code" href="struct_s_f_s_file_write_buffer__t.html">SFSFileWriteBuffer</a>* writeBuffer )
<a name="l00481"></a>00481 {
<a name="l00482"></a>00482         <span class="keywordflow">return</span> ( <a class="code" href="_f_s_disk_serv_8h.html#013362d3615068eee7220194a88a4d73" title="waits for and resets the gate&amp;#39;s value.">FS_IsComplete</a>( &amp;writeBuffer-&gt;<a class="code" href="struct_s_f_s_file_write_buffer__t.html#d0b3938d8a46849111f6b6b244c2e026">complete</a> ) );
<a name="l00483"></a>00483 }
<a name="l00484"></a>00484 
<a name="l00485"></a>00485 
<a name="l00486"></a>00486 <span class="comment">//**********************************************************</span>
<a name="l00488"></a>00488 <span class="comment"></span><span class="comment">//**********************************************************</span>
<a name="l00489"></a>00489 
<a name="l00490"></a>00490 <span class="comment">//----------------------------------------------------------</span>
<a name="l00491"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#10cc1bec4052cb5632c89bc9b1b6e633">00491</a> TCHAR* <a class="code" href="_f_s_disk_serv___w32_8cpp.html#10cc1bec4052cb5632c89bc9b1b6e633" title="File local functions.">ConvertString</a>( <span class="keyword">const</span> <a class="code" href="filesystem__afx_8h.html#08b81c947811e6def5d8994fd4d76481">FSchar</a>* <span class="keywordtype">string</span> )
<a name="l00492"></a>00492 {
<a name="l00493"></a>00493 <span class="preprocessor">#if !defined FS_USE_WIDECHAR</span>
<a name="l00494"></a>00494 <span class="preprocessor"></span>        <span class="keywordtype">size_t</span> <a class="code" href="glext_8h.html#2ba89f9e8d669bfad57028ce780865cd">len</a> = strlen( <span class="keywordtype">string</span> );
<a name="l00495"></a>00495         TCHAR* tstr = ( TCHAR* )<a class="code" href="_f_s_disk_serv___w32_8cpp.html#552500941af2ffc7f64f1e8a0fe00a0c" title="Memory management routines.">FSmalloc</a>( ( len + 1 ) * <span class="keyword">sizeof</span>( TCHAR ) );
<a name="l00496"></a>00496         MultiByteToWideChar( CP_UTF8, 0, <span class="keywordtype">string</span>, -1, tstr, ( <span class="keywordtype">int</span> )len );
<a name="l00497"></a>00497         tstr[ len ] = L<span class="charliteral">'\0'</span>;
<a name="l00498"></a>00498         <span class="keywordflow">return</span> tstr;
<a name="l00499"></a>00499 <span class="preprocessor">#else</span>
<a name="l00500"></a>00500 <span class="preprocessor"></span>        <span class="keywordflow">return</span> string;
<a name="l00501"></a>00501 <span class="preprocessor">#endif</span>
<a name="l00502"></a>00502 <span class="preprocessor"></span>}
<a name="l00503"></a>00503 
<a name="l00504"></a>00504 <span class="comment">//----------------------------------------------------------</span>
<a name="l00505"></a><a class="code" href="_f_s_disk_serv___w32_8cpp.html#cef30d4a2e6bb61af204268fb375313f">00505</a> <span class="keywordtype">void</span> <a class="code" href="_f_s_disk_serv___w32_8cpp.html#cef30d4a2e6bb61af204268fb375313f">FreeString</a>( TCHAR* <span class="keywordtype">string</span> )
<a name="l00506"></a>00506 {
<a name="l00507"></a>00507 <span class="preprocessor">#if !defined FS_USE_WIDECHAR</span>
<a name="l00508"></a>00508 <span class="preprocessor"></span>        <a class="code" href="_f_s_disk_serv___w32_8cpp.html#87b9c234664a4d2cfabf2071df203fa6">FSfree</a>( <span class="keywordtype">string</span> );
<a name="l00509"></a>00509 <span class="preprocessor">#endif</span>
<a name="l00510"></a>00510 <span class="preprocessor"></span>}
<a name="l00511"></a>00511 
<a name="l00512"></a>00512 <span class="comment">//----------------------------------------------------------</span>
<a name="l00513"></a>00513 <span class="keywordtype">void</span> Start()
<a name="l00514"></a>00514 {
<a name="l00516"></a>00516         atexit( Stop );
<a name="l00517"></a>00517 
<a name="l00519"></a>00519         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="_f_s_disk_serv___w32_8cpp.html#9d1051fc423c95127cfd80141482f402">MAX_DRIVE_COUNT</a>; ++i )
<a name="l00520"></a>00520                 _drives[ i ] = 0;
<a name="l00521"></a>00521 
<a name="l00523"></a>00523         <a class="code" href="_f_s_disk_serv_8h.html#639bb9787444e8c425eec0256793d968" title="File management functions.">FS_ScanDrives</a>();
<a name="l00524"></a>00524 
<a name="l00526"></a>00526         _workerThread = _beginthread( ThreadMain, 1024, 0 );
<a name="l00527"></a>00527 }
<a name="l00528"></a>00528 
<a name="l00529"></a>00529 <span class="comment">//----------------------------------------------------------</span>
<a name="l00530"></a>00530 <span class="keywordtype">void</span> Stop()
<a name="l00531"></a>00531 {
<a name="l00533"></a>00533         <a class="code" href="filesystem__afx_8h.html#942a7d92d20632b09a881e60b3b0da51" title="function prototypes to ease the reading of this file.">_FS_Swap</a>( &amp;_threadExit, 1 );
<a name="l00534"></a>00534         Sleep( 1 );
<a name="l00535"></a>00535 
<a name="l00537"></a>00537         <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; _freeRegistered; ++i )
<a name="l00538"></a>00538                 <a class="code" href="filesystem__afx_8h.html#7ae7b0600f1976c6219bf9c60f5a633d">_FS_AlignedFree</a>( ( <span class="keywordtype">void</span>* )_blocks[ i ] );
<a name="l00539"></a>00539 
<a name="l00541"></a>00541         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="_f_s_disk_serv___w32_8cpp.html#9d1051fc423c95127cfd80141482f402">MAX_DRIVE_COUNT</a>; ++i )
<a name="l00542"></a>00542         {
<a name="l00543"></a>00543                 <span class="keywordflow">if</span> ( _drives[ i ] )
<a name="l00544"></a>00544                 {
<a name="l00546"></a>00546                         <span class="keywordflow">if</span> ( _drives[ i ]-&gt;handle != INVALID_HANDLE_VALUE )
<a name="l00547"></a>00547                                 CloseHandle( _drives[ i ]-&gt;handle );
<a name="l00548"></a>00548 
<a name="l00550"></a>00550                         <a class="code" href="_f_s_disk_serv___w32_8cpp.html#87b9c234664a4d2cfabf2071df203fa6">FSfree</a>( ( <span class="keywordtype">void</span>* )_drives[ i ] );
<a name="l00551"></a>00551                 }
<a name="l00552"></a>00552         }
<a name="l00553"></a>00553 }
<a name="l00554"></a>00554 
<a name="l00555"></a>00555 <span class="comment">//----------------------------------------------------------</span>
<a name="l00556"></a>00556 <span class="keywordtype">void</span> InitDrive( <span class="keywordtype">char</span> letter )
<a name="l00557"></a>00557 {
<a name="l00559"></a>00559         <span class="keywordtype">char</span> <a class="code" href="glext_8h.html#c4fdb15bdbcd63430bab668b5419ed9f">buffer</a>[ 7 ] = <span class="stringliteral">"\\\\.\\_:"</span>;
<a name="l00560"></a>00560         buffer[ 4 ] = ( char )toupper( letter );
<a name="l00561"></a>00561 
<a name="l00563"></a>00563         TCHAR driveName[ 7 ];
<a name="l00564"></a>00564         <span class="keywordtype">int</span> result = MultiByteToWideChar( CP_UTF8, 0, buffer, -1, driveName, 7 );
<a name="l00565"></a>00565         <span class="keywordflow">if</span> ( result == 0 )
<a name="l00566"></a>00566         {
<a name="l00569"></a>00569                 DWORD error = GetLastError();
<a name="l00570"></a>00570                 <span class="keywordflow">return</span>;
<a name="l00571"></a>00571         }
<a name="l00572"></a>00572 
<a name="l00574"></a>00574         <a class="code" href="wglext_8h.html#a1efb7b85228601549d183556de19dfc">HANDLE</a> volume = CreateFile( driveName, GENERIC_READ | GENERIC_WRITE,
<a name="l00575"></a>00575                 FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_NO_BUFFERING,
<a name="l00576"></a>00576                 NULL );
<a name="l00577"></a>00577         <span class="keywordflow">if</span> ( volume == INVALID_HANDLE_VALUE )
<a name="l00578"></a>00578         {
<a name="l00579"></a>00579                 DWORD error = GetLastError();
<a name="l00580"></a>00580                 <span class="keywordflow">return</span>;
<a name="l00581"></a>00581         }
<a name="l00582"></a>00582 
<a name="l00584"></a>00584         <span class="keywordtype">int</span> <a class="code" href="glext_8h.html#57f14e05b1900f16a2da82ade47d0c6d">index</a> = GetDriveIndex( letter );
<a name="l00585"></a>00585         _drives[ index ] = ( <a class="code" href="struct_s_drive__t.html">SDrive</a>* )<a class="code" href="_f_s_disk_serv___w32_8cpp.html#552500941af2ffc7f64f1e8a0fe00a0c" title="Memory management routines.">FSmalloc</a>( <span class="keyword">sizeof</span>( <a class="code" href="struct_s_drive__t.html">SDrive_t</a> ) );
<a name="l00586"></a>00586 
<a name="l00588"></a>00588         _drives[ index ]-&gt;<a class="code" href="struct_s_drive__t.html#87d7bbf6cb8757f07cdeba13f05cf087">handle</a> = volume;
<a name="l00589"></a>00589         _drives[ index ]-&gt;<a class="code" href="struct_s_drive__t.html#c7f17137b18a64a3729c24790f263eb9" title="handle to the drive.">type</a> = <a class="code" href="_f_s_disk_serv___w32_8cpp.html#2a4fe9cb315ee694da76ba944eaf709a" title="drive types.">DTYPE_UNKNOWN</a>;
<a name="l00590"></a>00590         _drives[ index ]-&gt;<a class="code" href="struct_s_drive__t.html#6ce4b195fff6401ff3c0e0a14135ded0" title="CD-ROM, DVD-ROM, HDD, SSD, unknown.">bufferSize</a> = 0;
<a name="l00591"></a>00591 
<a name="l00593"></a>00593         DWORD bytesReturned = 0;
<a name="l00594"></a>00594         GET_MEDIA_TYPES* mediaTypes = ( GET_MEDIA_TYPES* )<a class="code" href="_f_s_disk_serv___w32_8cpp.html#552500941af2ffc7f64f1e8a0fe00a0c" title="Memory management routines.">FSmalloc</a>( 4096 );
<a name="l00595"></a>00595         <span class="keywordflow">if</span> ( DeviceIoControl( volume, IOCTL_STORAGE_GET_MEDIA_TYPES_EX, NULL, 0,
<a name="l00596"></a>00596                 mediaTypes, 4096, &amp;bytesReturned, NULL ) )
<a name="l00597"></a>00597         {
<a name="l00599"></a>00599                 DWORD deviceType = mediaTypes-&gt;DeviceType;
<a name="l00600"></a>00600                 DEVICE_MEDIA_INFO* mediaInfo = mediaTypes-&gt;MediaInfo;
<a name="l00601"></a>00601 
<a name="l00603"></a>00603                 <span class="keywordflow">if</span> ( deviceType == FILE_DEVICE_DVD )
<a name="l00604"></a>00604                         _drives[ index ]-&gt;<a class="code" href="struct_s_drive__t.html#c7f17137b18a64a3729c24790f263eb9" title="handle to the drive.">type</a> = <a class="code" href="_f_s_disk_serv___w32_8cpp.html#0585de32c9d4f05c6ffdac6cb1250a66">DTYPE_DVD</a>;
<a name="l00605"></a>00605                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( deviceType == FILE_DEVICE_CD_ROM )
<a name="l00606"></a>00606                         _drives[ index ]-&gt;<a class="code" href="struct_s_drive__t.html#c7f17137b18a64a3729c24790f263eb9" title="handle to the drive.">type</a> = <a class="code" href="_f_s_disk_serv___w32_8cpp.html#96150d499acf07fef7ded70fd4fa64f9">DTYPE_CD</a>;
<a name="l00607"></a>00607                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( deviceType == FILE_DEVICE_DISK )
<a name="l00608"></a>00608                         _drives[ index ]-&gt;<a class="code" href="struct_s_drive__t.html#c7f17137b18a64a3729c24790f263eb9" title="handle to the drive.">type</a> = <a class="code" href="_f_s_disk_serv___w32_8cpp.html#59280ff0687459cac3fb71320979ffb4">DTYPE_HDD</a>;
<a name="l00609"></a>00609         }
<a name="l00610"></a>00610         <span class="keywordflow">else</span>
<a name="l00611"></a>00611         {
<a name="l00612"></a>00612                 DWORD error = GetLastError();
<a name="l00613"></a>00613                 error = error;
<a name="l00614"></a>00614         }
<a name="l00615"></a>00615         <a class="code" href="_f_s_disk_serv___w32_8cpp.html#87b9c234664a4d2cfabf2071df203fa6">FSfree</a>( mediaTypes );
<a name="l00616"></a>00616 
<a name="l00617"></a>00617 <span class="preprocessor">#if 0</span>
<a name="l00619"></a>00619 <span class="preprocessor">        DISK_CACHE_INFORMATION diskCacheInfo;</span>
<a name="l00620"></a>00620 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ( DeviceIoControl( volume, IOCTL_DISK_GET_CACHE_INFORMATION, NULL, 0,
<a name="l00621"></a>00621                 &amp;diskCacheInfo, <span class="keyword">sizeof</span>( diskCacheInfo ), &amp;bytesReturned, NULL ) )
<a name="l00622"></a>00622         {
<a name="l00624"></a>00624 
<a name="l00625"></a>00625         }
<a name="l00626"></a>00626         <span class="keywordflow">else</span>
<a name="l00627"></a>00627         {
<a name="l00628"></a>00628                 DWORD error = GetLastError();
<a name="l00629"></a>00629                 error = error;
<a name="l00630"></a>00630         }
<a name="l00631"></a>00631 <span class="preprocessor">#else</span>
<a name="l00634"></a>00634 <span class="preprocessor">        if ( _drives[ index ]-&gt;type == DTYPE_HDD )</span>
<a name="l00635"></a>00635 <span class="preprocessor"></span>        {
<a name="l00636"></a>00636                 _drives[ index ]-&gt;<a class="code" href="struct_s_drive__t.html#6ce4b195fff6401ff3c0e0a14135ded0" title="CD-ROM, DVD-ROM, HDD, SSD, unknown.">bufferSize</a> = <a class="code" href="_f_s_disk_serv___w32_8cpp.html#05ce56e00d6fd51940257e8718ba3a88">DISKCACHE_SIZE_HDD</a>;
<a name="l00637"></a>00637                 _drives[ index ]-&gt;<a class="code" href="struct_s_drive__t.html#82bfb5892551f2b4ae7d1bfea9fd16bb" title="size of the drive&amp;#39;s cache in bytes.">maxLASize</a> = <a class="code" href="_f_s_disk_serv___w32_8cpp.html#7bbed87240f78355659b4285558e6a55">LOOKAHEAD_SIZE_HDD</a>;
<a name="l00638"></a>00638                 _drives[ index ]-&gt;<a class="code" href="struct_s_drive__t.html#9751e7f3772821f7eb220fd9f36475e5" title="maximum size of a look-ahead read.">maxLACount</a> = <a class="code" href="_f_s_disk_serv___w32_8cpp.html#2177b3fe8493058fb7fa092ecf8bdbd6">LOOKAHEAD_COUNT_HDD</a>;
<a name="l00639"></a>00639                 _drives[ index ]-&gt;<a class="code" href="struct_s_drive__t.html#53e9e2a8c991d51eb458b07fb96b4620" title="maximum number of reads to look-ahead.">maxSeekBack</a> = <a class="code" href="_f_s_disk_serv___w32_8cpp.html#4f2067f0c6d65cc2382026aae315e15f">SEEKBACK_SIZE_HDD</a>;
<a name="l00640"></a>00640         }
<a name="l00641"></a>00641         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( _drives[ index ]-&gt;<a class="code" href="_g_l_8h.html#7d05960f4f1c1b11f3177dc963a45d86">type</a> == <a class="code" href="_f_s_disk_serv___w32_8cpp.html#0585de32c9d4f05c6ffdac6cb1250a66">DTYPE_DVD</a> )
<a name="l00642"></a>00642         {
<a name="l00643"></a>00643                 _drives[ index ]-&gt;<a class="code" href="struct_s_drive__t.html#6ce4b195fff6401ff3c0e0a14135ded0" title="CD-ROM, DVD-ROM, HDD, SSD, unknown.">bufferSize</a> = <a class="code" href="_f_s_disk_serv___w32_8cpp.html#4a3a2dd180a995d513762c53c95bd598">DISKCACHE_SIZE_DVD</a>;
<a name="l00644"></a>00644                 _drives[ index ]-&gt;<a class="code" href="struct_s_drive__t.html#82bfb5892551f2b4ae7d1bfea9fd16bb" title="size of the drive&amp;#39;s cache in bytes.">maxLASize</a> = <a class="code" href="_f_s_disk_serv___w32_8cpp.html#af5e2dcc3f408e04b8ec74c129404749">LOOKAHEAD_SIZE_DVD</a>;
<a name="l00645"></a>00645                 _drives[ index ]-&gt;<a class="code" href="struct_s_drive__t.html#9751e7f3772821f7eb220fd9f36475e5" title="maximum size of a look-ahead read.">maxLACount</a> = <a class="code" href="_f_s_disk_serv___w32_8cpp.html#a7e35654383715365ac83c6dc625d43d">LOOKAHEAD_COUNT_DVD</a>;
<a name="l00646"></a>00646                 _drives[ index ]-&gt;<a class="code" href="struct_s_drive__t.html#53e9e2a8c991d51eb458b07fb96b4620" title="maximum number of reads to look-ahead.">maxSeekBack</a> = <a class="code" href="_f_s_disk_serv___w32_8cpp.html#7be663e58042a12b717c191c8ab8b5c5">SEEKBACK_SIZE_DVD</a>;
<a name="l00647"></a>00647         }
<a name="l00648"></a>00648         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( _drives[ index ]-&gt;<a class="code" href="_g_l_8h.html#7d05960f4f1c1b11f3177dc963a45d86">type</a> == <a class="code" href="_f_s_disk_serv___w32_8cpp.html#96150d499acf07fef7ded70fd4fa64f9">DTYPE_CD</a> )
<a name="l00649"></a>00649         {
<a name="l00650"></a>00650                 _drives[ index ]-&gt;<a class="code" href="struct_s_drive__t.html#6ce4b195fff6401ff3c0e0a14135ded0" title="CD-ROM, DVD-ROM, HDD, SSD, unknown.">bufferSize</a> = <a class="code" href="_f_s_disk_serv___w32_8cpp.html#dc1c85a7d6e638c59856846ef388ec3e">DISKCACHE_SIZE_CD</a>;
<a name="l00651"></a>00651                 _drives[ index ]-&gt;<a class="code" href="struct_s_drive__t.html#82bfb5892551f2b4ae7d1bfea9fd16bb" title="size of the drive&amp;#39;s cache in bytes.">maxLASize</a> = <a class="code" href="_f_s_disk_serv___w32_8cpp.html#c88e4ff9f0777c5ae5464096aa000832">LOOKAHEAD_SIZE_CD</a>;
<a name="l00652"></a>00652                 _drives[ index ]-&gt;<a class="code" href="struct_s_drive__t.html#9751e7f3772821f7eb220fd9f36475e5" title="maximum size of a look-ahead read.">maxLACount</a> = <a class="code" href="_f_s_disk_serv___w32_8cpp.html#73bbedde51b2263293c087d4ee3a45a9">LOOKAHEAD_COUNT_CD</a>;
<a name="l00653"></a>00653                 _drives[ index ]-&gt;<a class="code" href="struct_s_drive__t.html#53e9e2a8c991d51eb458b07fb96b4620" title="maximum number of reads to look-ahead.">maxSeekBack</a> = <a class="code" href="_f_s_disk_serv___w32_8cpp.html#7d9a55bc9b2f042ecb83d94fe0e6aea1">SEEKBACK_SIZE_CD</a>;
<a name="l00654"></a>00654         }
<a name="l00655"></a>00655 <span class="preprocessor">#endif</span>
<a name="l00656"></a>00656 <span class="preprocessor"></span>
<a name="l00658"></a>00658         DWORD bytesPerSector = 0;
<a name="l00659"></a>00659         DWORD sectorsPerCluster = 0;
<a name="l00660"></a>00660         DWORD freeClusters = 0;
<a name="l00661"></a>00661         DWORD totalClusters = 0;
<a name="l00662"></a>00662         <span class="keywordflow">if</span> ( GetDiskFreeSpace( driveName + 4, &amp;sectorsPerCluster, &amp;bytesPerSector, &amp;freeClusters, &amp;totalClusters ) )
<a name="l00663"></a>00663         {
<a name="l00664"></a>00664                 _drives[ index ]-&gt;<a class="code" href="struct_s_drive__t.html#c54a18e038048b9de16430fdcaa62019" title="maximum number of bytes to read-back.">bytesPerSector</a> = bytesPerSector;
<a name="l00665"></a>00665                 _drives[ index ]-&gt;<a class="code" href="struct_s_drive__t.html#840f05d50889266ea6de3979fa0425be" title="number of bytes per sector.">sectorsPerCluster</a> = sectorsPerCluster;
<a name="l00666"></a>00666                 _drives[ index ]-&gt;<a class="code" href="struct_s_drive__t.html#a294ea64310e043f9891336769bdbfa6" title="number of sectors per cluster.">bytesPerCluster</a> = bytesPerSector * sectorsPerCluster;
<a name="l00667"></a>00667         }
<a name="l00668"></a>00668         <span class="keywordflow">else</span>
<a name="l00669"></a>00669         {
<a name="l00670"></a>00670                 DWORD error = GetLastError();
<a name="l00671"></a>00671                 error = error;
<a name="l00672"></a>00672         }
<a name="l00673"></a>00673 }
<a name="l00674"></a>00674 
<a name="l00675"></a>00675 <span class="comment">//----------------------------------------------------------</span>
<a name="l00676"></a>00676 <span class="keywordtype">int</span> GetDriveIndex( <span class="keywordtype">char</span> letter )
<a name="l00677"></a>00677 {
<a name="l00680"></a>00680         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> d0 = ( <span class="keywordtype">unsigned</span> char )( letter - <span class="charliteral">'A'</span> );
<a name="l00681"></a>00681         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> d1 = ( <span class="keywordtype">unsigned</span> char )( letter - <span class="charliteral">'a'</span> );
<a name="l00682"></a>00682         <span class="keywordflow">return</span> ( <span class="keywordtype">int</span> )<a class="code" href="_u_t_x_8cpp.html#3f06f0e9f7beb8214afeea0b18ef8377">min</a>( d0, d1 );
<a name="l00683"></a>00683 }
<a name="l00684"></a>00684 
<a name="l00685"></a>00685 <span class="comment">//----------------------------------------------------------</span>
<a name="l00686"></a>00686 <span class="keywordtype">void</span> FlushDriveQueue( <span class="keywordtype">int</span> drive )
<a name="l00687"></a>00687 {
<a name="l00689"></a>00689         <span class="keywordflow">while</span> ( <a class="code" href="filesystem__afx_8h.html#942a7d92d20632b09a881e60b3b0da51" title="function prototypes to ease the reading of this file.">_FS_Swap</a>( _queuePushLock + drive, 1 ) != 0 )
<a name="l00690"></a>00690                 _FS_Pause();
<a name="l00691"></a>00691 
<a name="l00694"></a>00694         <span class="keywordflow">while</span> ( ( _queuePushIdx[ drive ] - _queuePopIdx[ drive ] ) &gt; 0 )
<a name="l00695"></a>00695                 _FS_Pause();
<a name="l00696"></a>00696 
<a name="l00698"></a>00698         <a class="code" href="filesystem__afx_8h.html#942a7d92d20632b09a881e60b3b0da51" title="function prototypes to ease the reading of this file.">_FS_Swap</a>( _queuePushLock + drive, 0 );
<a name="l00699"></a>00699 }
<a name="l00700"></a>00700 
<a name="l00701"></a>00701 <span class="comment">//----------------------------------------------------------</span>
<a name="l00702"></a>00702 <span class="keywordtype">void</span> ThreadMain( <span class="keywordtype">void</span>* )
<a name="l00703"></a>00703 {
<a name="l00705"></a>00705         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> readCount = 0;
<a name="l00706"></a>00706         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> writeCount = 0;
<a name="l00707"></a>00707 
<a name="l00709"></a>00709         <a class="code" href="filesystem__afx_8h.html#2dfedf2033eee861d23c808f79ed5837">FSsize</a> curDriveLoc[ MAX_DRIVE_COUNT ];
<a name="l00710"></a>00710         memset( curDriveLoc, 0, <span class="keyword">sizeof</span>( curDriveLoc ) );
<a name="l00711"></a>00711 
<a name="l00713"></a>00713         <a class="code" href="wglext_8h.html#a1efb7b85228601549d183556de19dfc">HANDLE</a> alwaysSet = CreateEvent( NULL, TRUE, FALSE, NULL );
<a name="l00714"></a>00714 
<a name="l00716"></a>00716         <span class="keywordflow">while</span> ( <a class="code" href="filesystem__afx_8h.html#942a7d92d20632b09a881e60b3b0da51" title="function prototypes to ease the reading of this file.">_FS_Swap</a>( &amp;_threadExit, 0 ) == 0 )
<a name="l00717"></a>00717         {
<a name="l00720"></a>00720                 <span class="keywordtype">bool</span> workDone = <span class="keyword">false</span>;
<a name="l00721"></a>00721 
<a name="l00723"></a>00723                 <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; MAX_DRIVE_COUNT; ++i )
<a name="l00724"></a>00724                 {
<a name="l00726"></a>00726                         <span class="keyword">volatile</span> <a class="code" href="struct_s_drive__t.html">SDrive</a>* drive = _drives[ i ];
<a name="l00727"></a>00727                         <span class="keywordflow">if</span> ( !drive )
<a name="l00728"></a>00728                                 <span class="keywordflow">continue</span>;
<a name="l00729"></a>00729 
<a name="l00732"></a>00732                         <span class="keywordflow">if</span> ( _queuePushIdx[ i ] == _queuePopIdx[ i ] )
<a name="l00733"></a>00733                                 <span class="keywordflow">continue</span>;
<a name="l00734"></a>00734 
<a name="l00736"></a>00736                         <a class="code" href="struct_s_file_op__t.html">SFileOp</a>* curOp = _ops[ i ] + _queuePopIdx[ i ] % <a class="code" href="_f_s_disk_serv___w32_8cpp.html#ecc4c5fadbda3d12a5a810f93cf2fe43">MAX_PENDING_IO</a>;
<a name="l00737"></a>00737 
<a name="l00739"></a>00739                         <span class="keywordflow">if</span> ( curOp-&gt;<a class="code" href="struct_s_file_op__t.html#b7c0b908f7ae23db0ed6963eb79335e8" title="amount of data to read/write.">retired</a> )
<a name="l00740"></a>00740                         {
<a name="l00743"></a>00743                                 curOp-&gt;<a class="code" href="struct_s_file_op__t.html#b7c0b908f7ae23db0ed6963eb79335e8" title="amount of data to read/write.">retired</a> = 0;
<a name="l00744"></a>00744                                 _FS_Increment( _queuePopIdx + i );
<a name="l00745"></a>00745                                 <span class="keywordflow">continue</span>;
<a name="l00746"></a>00746                         }
<a name="l00747"></a>00747 
<a name="l00751"></a>00751                         <span class="keywordtype">bool</span> laOpFound = <span class="keyword">false</span>;
<a name="l00752"></a>00752 
<a name="l00755"></a>00755                         <a class="code" href="filesystem__afx_8h.html#2dfedf2033eee861d23c808f79ed5837">FSsize</a> targetAddr = CalcPhysAddr( curOp );
<a name="l00756"></a>00756                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxScan = ( <span class="keywordtype">unsigned</span> <a class="code" href="_g_l_aux_8h.html#b832c174e145540d491b0830fc05dbb1">int</a> )<a class="code" href="_u_t_x_8cpp.html#3f06f0e9f7beb8214afeea0b18ef8377">min</a>( ( <span class="keywordtype">int</span> )drive-&gt;<a class="code" href="struct_s_drive__t.html#9751e7f3772821f7eb220fd9f36475e5" title="maximum size of a look-ahead read.">maxLACount</a>, ( _queuePushIdx[ i ] - _queuePopIdx[ i ] ) );
<a name="l00757"></a>00757                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> scanIdx = _queuePopIdx[ i ] + 1;
<a name="l00758"></a>00758                         <span class="keywordflow">if</span> ( targetAddr &gt;= curDriveLoc[ i ] )
<a name="l00759"></a>00759                         {
<a name="l00760"></a>00760                                 <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 1; j &lt; maxScan; ++j, ++scanIdx )
<a name="l00761"></a>00761                                 {
<a name="l00763"></a>00763                                         <a class="code" href="struct_s_file_op__t.html">SFileOp</a>* lookAheadOp = _ops[ i ] + ( scanIdx % <a class="code" href="_f_s_disk_serv___w32_8cpp.html#ecc4c5fadbda3d12a5a810f93cf2fe43">MAX_PENDING_IO</a> );
<a name="l00764"></a>00764 
<a name="l00768"></a>00768                                         <span class="keywordflow">if</span> ( lookAheadOp-&gt;<a class="code" href="struct_s_file_op__t.html#35a76a584a5395b66dc709e5a81a690a" title="non-zero for a read event.">writeBuffer</a> != 0 &amp;&amp; ( lookAheadOp-&gt;<a class="code" href="struct_s_file_op__t.html#d11881794d5507b1eee0c41a840b7062" title="non-zero for a write event.">file</a>-&gt;<a class="code" href="struct_s_file__t.html#4dafbf10076baf07fe478e79a33fdc8b" title="Win32 file handle.">flags</a> &amp; <a class="code" href="_f_s_disk_serv_8h.html#08eb85ecc5402f34f9ef86c27f178c72">FS_FILE_WRITE_REORDER</a> ) == 0 )
<a name="l00769"></a>00769                                                 <span class="keywordflow">break</span>;
<a name="l00770"></a>00770 
<a name="l00773"></a>00773                                         <span class="keywordflow">if</span> ( lookAheadOp-&gt;<a class="code" href="struct_s_file_op__t.html#b7c0b908f7ae23db0ed6963eb79335e8" title="amount of data to read/write.">retired</a> &gt; 0 )
<a name="l00774"></a>00774                                                 <span class="keywordflow">continue</span>;
<a name="l00775"></a>00775 
<a name="l00778"></a>00778                                         <span class="keywordflow">if</span> ( lookAheadOp-&gt;<a class="code" href="struct_s_file_op__t.html#3d23fc9294b4099d03479ecc39867c5d" title="file pointer.">size</a> &gt; drive-&gt;<a class="code" href="struct_s_drive__t.html#82bfb5892551f2b4ae7d1bfea9fd16bb" title="size of the drive&amp;#39;s cache in bytes.">maxLASize</a> )
<a name="l00779"></a>00779                                                 <span class="keywordflow">continue</span>;
<a name="l00780"></a>00780 
<a name="l00784"></a>00784                                         <a class="code" href="filesystem__afx_8h.html#2dfedf2033eee861d23c808f79ed5837">FSsize</a> curAddr = CalcPhysAddr( lookAheadOp );
<a name="l00785"></a>00785                                         <span class="keywordflow">if</span> ( curAddr &gt; curDriveLoc[ i ] &amp;&amp; curAddr &lt; targetAddr )
<a name="l00786"></a>00786                                         {
<a name="l00787"></a>00787                                                 targetAddr = curAddr;
<a name="l00788"></a>00788                                                 curOp = lookAheadOp;
<a name="l00789"></a>00789                                                 laOpFound = <span class="keyword">true</span>;
<a name="l00790"></a>00790                                         }
<a name="l00791"></a>00791                                 }
<a name="l00792"></a>00792                         }
<a name="l00793"></a>00793                         <span class="keywordflow">else</span>
<a name="l00794"></a>00794                         {
<a name="l00797"></a>00797                                 <a class="code" href="filesystem__afx_8h.html#2dfedf2033eee861d23c808f79ed5837">FSsize</a> baseAddr = targetAddr;
<a name="l00798"></a>00798                                 <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 1; j &lt; maxScan; ++j, ++scanIdx )
<a name="l00799"></a>00799                                 {
<a name="l00801"></a>00801                                         <a class="code" href="struct_s_file_op__t.html">SFileOp</a>* lookAheadOp = _ops[ i ] + ( scanIdx % <a class="code" href="_f_s_disk_serv___w32_8cpp.html#ecc4c5fadbda3d12a5a810f93cf2fe43">MAX_PENDING_IO</a> );
<a name="l00802"></a>00802                                         
<a name="l00806"></a>00806                                         <span class="keywordflow">if</span> ( lookAheadOp-&gt;<a class="code" href="struct_s_file_op__t.html#35a76a584a5395b66dc709e5a81a690a" title="non-zero for a read event.">writeBuffer</a> != 0 &amp;&amp; ( lookAheadOp-&gt;<a class="code" href="struct_s_file_op__t.html#d11881794d5507b1eee0c41a840b7062" title="non-zero for a write event.">file</a>-&gt;<a class="code" href="struct_s_file__t.html#4dafbf10076baf07fe478e79a33fdc8b" title="Win32 file handle.">flags</a> &amp; <a class="code" href="_f_s_disk_serv_8h.html#08eb85ecc5402f34f9ef86c27f178c72">FS_FILE_WRITE_REORDER</a> ) == 0 )
<a name="l00807"></a>00807                                                 <span class="keywordflow">break</span>;
<a name="l00808"></a>00808 
<a name="l00811"></a>00811                                         <span class="keywordflow">if</span> ( lookAheadOp-&gt;<a class="code" href="struct_s_file_op__t.html#b7c0b908f7ae23db0ed6963eb79335e8" title="amount of data to read/write.">retired</a> &gt; 0 )
<a name="l00812"></a>00812                                                 <span class="keywordflow">continue</span>;
<a name="l00813"></a>00813 
<a name="l00816"></a>00816                                         <span class="keywordflow">if</span> ( lookAheadOp-&gt;<a class="code" href="struct_s_file_op__t.html#3d23fc9294b4099d03479ecc39867c5d" title="file pointer.">size</a> &gt; drive-&gt;<a class="code" href="struct_s_drive__t.html#82bfb5892551f2b4ae7d1bfea9fd16bb" title="size of the drive&amp;#39;s cache in bytes.">maxLASize</a> )
<a name="l00817"></a>00817                                                 <span class="keywordflow">continue</span>;
<a name="l00818"></a>00818 
<a name="l00822"></a>00822                                         <a class="code" href="filesystem__afx_8h.html#2dfedf2033eee861d23c808f79ed5837">FSsize</a> curAddr = CalcPhysAddr( lookAheadOp );
<a name="l00823"></a>00823                                         <span class="keywordflow">if</span> ( curAddr &lt; targetAddr )
<a name="l00824"></a>00824                                         {
<a name="l00825"></a>00825                                                 <span class="keywordflow">if</span> ( ( baseAddr - curAddr ) &lt; drive-&gt;<a class="code" href="struct_s_drive__t.html#53e9e2a8c991d51eb458b07fb96b4620" title="maximum number of reads to look-ahead.">maxSeekBack</a> )
<a name="l00826"></a>00826                                                 {
<a name="l00827"></a>00827                                                         targetAddr = curAddr;
<a name="l00828"></a>00828                                                         curOp = lookAheadOp;
<a name="l00829"></a>00829                                                         laOpFound = <span class="keyword">true</span>;
<a name="l00830"></a>00830                                                 }
<a name="l00831"></a>00831                                         }
<a name="l00832"></a>00832                                 }
<a name="l00833"></a>00833                         }
<a name="l00834"></a>00834 
<a name="l00836"></a>00836                         <a class="code" href="struct_s_file__t.html" title="internal structures.">SFile</a>* file = curOp-&gt;<a class="code" href="struct_s_file_op__t.html#d11881794d5507b1eee0c41a840b7062" title="non-zero for a write event.">file</a>;
<a name="l00837"></a>00837 
<a name="l00840"></a>00840                         workDone = <span class="keyword">true</span>;
<a name="l00841"></a>00841 
<a name="l00843"></a>00843                         <span class="keywordflow">if</span> ( curOp-&gt;<a class="code" href="struct_s_file_op__t.html#a85b29f1d72b6b477e9e4ba93f18be1c">readBuffer</a> )
<a name="l00844"></a>00844                         {
<a name="l00845"></a>00845                                 assert( !curOp-&gt;<a class="code" href="struct_s_file_op__t.html#35a76a584a5395b66dc709e5a81a690a" title="non-zero for a read event.">writeBuffer</a> );
<a name="l00846"></a>00846 
<a name="l00848"></a>00848                                 <span class="keywordflow">if</span> ( !ReadFileEx( file-&gt;<a class="code" href="struct_s_file__t.html#9c5b15b8c07aca9928c6a347e765d60f">handle</a>, ( <span class="keywordtype">void</span>* )curOp-&gt;<a class="code" href="struct_s_file_op__t.html#a85b29f1d72b6b477e9e4ba93f18be1c">readBuffer</a>-&gt;<a class="code" href="struct_s_f_s_file_read_buffer__t.html#bc7bdce1c0dfdad630db6fedce106bab">buffer</a>, curOp-&gt;<a class="code" href="struct_s_file_op__t.html#3d23fc9294b4099d03479ecc39867c5d" title="file pointer.">size</a>,
<a name="l00849"></a>00849                                         ( LPOVERLAPPED )&amp;curOp-&gt;<a class="code" href="struct_s_file_op__t.html#7580e2d7725d9e62b6f01af716882b5a">overlapped</a>, IOComplete ) )
<a name="l00850"></a>00850                                 {
<a name="l00853"></a>00853                                         <a class="code" href="filesystem__afx_8h.html#942a7d92d20632b09a881e60b3b0da51" title="function prototypes to ease the reading of this file.">_FS_Swap</a>( &amp;curOp-&gt;<a class="code" href="struct_s_file_op__t.html#a85b29f1d72b6b477e9e4ba93f18be1c">readBuffer</a>-&gt;<a class="code" href="struct_s_f_s_file_read_buffer__t.html#87bd7289db7343742a40bdc52f4fff0a">complete</a>, 1 );
<a name="l00854"></a>00854                                 }
<a name="l00855"></a>00855                                 ++readCount;
<a name="l00856"></a>00856                         }
<a name="l00857"></a>00857                         <span class="keywordflow">else</span>
<a name="l00858"></a>00858                         {
<a name="l00860"></a>00860                                 <span class="keywordflow">if</span> ( !WriteFileEx( file-&gt;<a class="code" href="struct_s_file__t.html#9c5b15b8c07aca9928c6a347e765d60f">handle</a>, ( <span class="keywordtype">void</span>* )curOp-&gt;<a class="code" href="struct_s_file_op__t.html#35a76a584a5395b66dc709e5a81a690a" title="non-zero for a read event.">writeBuffer</a>-&gt;<a class="code" href="struct_s_f_s_file_write_buffer__t.html#e7d9298412a9564b5eeec70f8095ed37">buffer</a>, curOp-&gt;<a class="code" href="struct_s_file_op__t.html#3d23fc9294b4099d03479ecc39867c5d" title="file pointer.">size</a>,
<a name="l00861"></a>00861                                         ( LPOVERLAPPED )&amp;curOp-&gt;<a class="code" href="struct_s_file_op__t.html#7580e2d7725d9e62b6f01af716882b5a">overlapped</a>, IOComplete ) )
<a name="l00862"></a>00862                                 {
<a name="l00865"></a>00865                                         <a class="code" href="filesystem__afx_8h.html#942a7d92d20632b09a881e60b3b0da51" title="function prototypes to ease the reading of this file.">_FS_Swap</a>( &amp;curOp-&gt;<a class="code" href="struct_s_file_op__t.html#35a76a584a5395b66dc709e5a81a690a" title="non-zero for a read event.">writeBuffer</a>-&gt;<a class="code" href="struct_s_f_s_file_write_buffer__t.html#d0b3938d8a46849111f6b6b244c2e026">complete</a>, 1 );
<a name="l00866"></a>00866                                 }
<a name="l00867"></a>00867                                 ++writeCount;
<a name="l00868"></a>00868                         }
<a name="l00869"></a>00869 
<a name="l00871"></a>00871                         curDriveLoc[ i ] = targetAddr;
<a name="l00872"></a>00872 
<a name="l00875"></a>00875                         <span class="keywordflow">if</span> ( laOpFound )
<a name="l00876"></a>00876                                 curOp-&gt;<a class="code" href="struct_s_file_op__t.html#b7c0b908f7ae23db0ed6963eb79335e8" title="amount of data to read/write.">retired</a> = 1;
<a name="l00877"></a>00877                         <span class="keywordflow">else</span>
<a name="l00878"></a>00878                                 _FS_Increment( _queuePopIdx + i );
<a name="l00879"></a>00879                 }
<a name="l00880"></a>00880 
<a name="l00882"></a>00882                 DWORD result = WaitForSingleObjectEx( alwaysSet, 0, TRUE );
<a name="l00883"></a>00883                 result = result;
<a name="l00884"></a>00884         }
<a name="l00885"></a>00885 <span class="comment">//      timeEndPeriod( 1 );</span>
<a name="l00886"></a>00886         CloseHandle( alwaysSet );
<a name="l00887"></a>00887 
<a name="l00888"></a>00888         readCount = readCount;
<a name="l00889"></a>00889         writeCount = writeCount;
<a name="l00890"></a>00890 }
<a name="l00891"></a>00891 
<a name="l00892"></a>00892 <span class="comment">//----------------------------------------------------------</span>
<a name="l00893"></a>00893 <span class="keywordtype">void</span> CALLBACK IOComplete( DWORD dwErrorCode, DWORD dwBytesTransfered, LPOVERLAPPED overlapped )
<a name="l00894"></a>00894 {
<a name="l00898"></a>00898         <span class="keyword">volatile</span> <a class="code" href="struct_s_file_op__t.html">SFileOp</a>* fileOp = ( <span class="keyword">volatile</span> <a class="code" href="struct_s_file_op__t.html">SFileOp</a>* )overlapped;
<a name="l00899"></a>00899 
<a name="l00901"></a>00901         <span class="keywordflow">if</span> ( fileOp-&gt;<a class="code" href="struct_s_file_op__t.html#a85b29f1d72b6b477e9e4ba93f18be1c">readBuffer</a> )
<a name="l00902"></a>00902                 <a class="code" href="filesystem__afx_8h.html#942a7d92d20632b09a881e60b3b0da51" title="function prototypes to ease the reading of this file.">_FS_Swap</a>( &amp;fileOp-&gt;<a class="code" href="struct_s_file_op__t.html#a85b29f1d72b6b477e9e4ba93f18be1c">readBuffer</a>-&gt;<a class="code" href="struct_s_f_s_file_read_buffer__t.html#87bd7289db7343742a40bdc52f4fff0a">complete</a>, 1 );
<a name="l00903"></a>00903         <span class="keywordflow">else</span>
<a name="l00904"></a>00904                 <a class="code" href="filesystem__afx_8h.html#942a7d92d20632b09a881e60b3b0da51" title="function prototypes to ease the reading of this file.">_FS_Swap</a>( &amp;fileOp-&gt;<a class="code" href="struct_s_file_op__t.html#35a76a584a5395b66dc709e5a81a690a" title="non-zero for a read event.">writeBuffer</a>-&gt;<a class="code" href="struct_s_f_s_file_write_buffer__t.html#d0b3938d8a46849111f6b6b244c2e026">complete</a>, 1 );
<a name="l00905"></a>00905 
<a name="l00907"></a>00907         <a class="code" href="filesystem__afx_8h.html#942a7d92d20632b09a881e60b3b0da51" title="function prototypes to ease the reading of this file.">_FS_Swap</a>( &amp;fileOp-&gt;<a class="code" href="struct_s_file_op__t.html#5d5cf61968a0cb6006012635d2754544" title="prefetch retire flag.">pending</a>, 0 );
<a name="l00908"></a>00908 }
<a name="l00909"></a>00909 
<a name="l00910"></a>00910 <span class="comment">//----------------------------------------------------------</span>
<a name="l00911"></a>00911 <a class="code" href="filesystem__afx_8h.html#2dfedf2033eee861d23c808f79ed5837">FSsize</a> CalcPhysAddr( <a class="code" href="struct_s_file_op__t.html">SFileOp</a>* op )
<a name="l00912"></a>00912 {
<a name="l00914"></a>00914         <a class="code" href="filesystem__afx_8h.html#2dfedf2033eee861d23c808f79ed5837">FSsize</a> targetAddr = op-&gt;<a class="code" href="struct_s_file_op__t.html#d11881794d5507b1eee0c41a840b7062" title="non-zero for a write event.">file</a>-&gt;<a class="code" href="struct_s_file__t.html#28381f30fa5e5f18fd8c6e6d7f2a76f3" title="absolute file offset.">physAddr</a>;
<a name="l00915"></a>00915         <a class="code" href="filesystem__afx_8h.html#2dfedf2033eee861d23c808f79ed5837">FSsize</a> fileOffset = <a class="code" href="filesystem__afx_8h.html#fd795f2042c2f66113f5a2bf2ddadea9">MAKE_FSIZE</a>( op-&gt;<a class="code" href="struct_s_file_op__t.html#7580e2d7725d9e62b6f01af716882b5a">overlapped</a>.Offset, op-&gt;<a class="code" href="struct_s_file_op__t.html#7580e2d7725d9e62b6f01af716882b5a">overlapped</a>.OffsetHigh );
<a name="l00916"></a>00916 
<a name="l00918"></a>00918         <span class="keywordflow">return</span> targetAddr + fileOffset;
<a name="l00919"></a>00919 }
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Feb 13 17:19:51 2009 for Bootstrap Engine by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
