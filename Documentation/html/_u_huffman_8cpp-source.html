<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Bootstrap Engine: C:/Bootstrap/ProjectBX/Documentation/Code/Engine/Common/UHuffman.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>C:/Bootstrap/ProjectBX/Documentation/Code/Engine/Common/UHuffman.cpp</h1><a href="_u_huffman_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//----------------------------------------------------------</span>
<a name="l00006"></a>00006 <span class="comment"></span><span class="comment">//----------------------------------------------------------</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include "<a class="code" href="common__afx_8h.html">common_afx.h</a>"</span>
<a name="l00008"></a>00008 
<a name="l00010"></a>00010 <span class="preprocessor">#include "<a class="code" href="_u_huffman_8h.html">UHuffman.h</a>"</span>
<a name="l00011"></a>00011 
<a name="l00013"></a>00013 <span class="preprocessor">#include "<a class="code" href="_u_bit_reader_8h.html">UBitReader.h</a>"</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include "<a class="code" href="_u_bit_writer_8h.html">UBitWriter.h</a>"</span>
<a name="l00015"></a>00015 
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;set&gt;</span>
<a name="l00019"></a>00019 
<a name="l00020"></a><a class="code" href="struct_s_node.html">00020</a> <span class="keyword">struct </span><a class="code" href="struct_s_node.html" title="class header.">SNode</a>
<a name="l00021"></a>00021 {
<a name="l00023"></a><a class="code" href="struct_s_node.html#747ebe0b867eba254743b863ad2d9a8e">00023</a>         <a class="code" href="struct_s_node.html#747ebe0b867eba254743b863ad2d9a8e" title="ctor.">SNode</a>() : <a class="code" href="struct_s_node.html#34a7a4584233ff71a079c7cc8af0d540" title="internal node data.">parent</a>( 0 ), <a class="code" href="struct_s_node.html#fdf34ae214ee5ba96cbdefd552dfbd67">score</a>( 0 ), <a class="code" href="struct_s_node.html#2089f30eda8aa96bbde23af8e2aa53d2">value</a>( 0 ) { }
<a name="l00024"></a>00024 
<a name="l00026"></a><a class="code" href="struct_s_node.html#34a7a4584233ff71a079c7cc8af0d540">00026</a>         <a class="code" href="struct_s_node.html" title="class header.">SNode</a>* <a class="code" href="struct_s_node.html#34a7a4584233ff71a079c7cc8af0d540" title="internal node data.">parent</a>;
<a name="l00027"></a><a class="code" href="struct_s_node.html#fdf34ae214ee5ba96cbdefd552dfbd67">00027</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="struct_s_node.html#fdf34ae214ee5ba96cbdefd552dfbd67">score</a>;
<a name="l00028"></a><a class="code" href="struct_s_node.html#2089f30eda8aa96bbde23af8e2aa53d2">00028</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="struct_s_node.html#2089f30eda8aa96bbde23af8e2aa53d2">value</a>;
<a name="l00029"></a>00029 };
<a name="l00030"></a>00030 
<a name="l00031"></a><a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">00031</a> <span class="preprocessor">#define REV( x )                                ( ( ( x &amp; 0x01 ) &lt;&lt; 7 ) | \</span>
<a name="l00032"></a>00032 <span class="preprocessor">                                                                  ( ( x &amp; 0x02 ) &lt;&lt; 5 ) | \</span>
<a name="l00033"></a>00033 <span class="preprocessor">                                                                  ( ( x &amp; 0x04 ) &lt;&lt; 3 ) | \</span>
<a name="l00034"></a>00034 <span class="preprocessor">                                                                  ( ( x &amp; 0x08 ) &lt;&lt; 1 ) | \</span>
<a name="l00035"></a>00035 <span class="preprocessor">                                                                  ( ( x &amp; 0x10 ) &gt;&gt; 1 ) | \</span>
<a name="l00036"></a>00036 <span class="preprocessor">                                                                  ( ( x &amp; 0x20 ) &gt;&gt; 3 ) | \</span>
<a name="l00037"></a>00037 <span class="preprocessor">                                                                  ( ( x &amp; 0x40 ) &gt;&gt; 5 ) | \</span>
<a name="l00038"></a>00038 <span class="preprocessor">                                                                  ( ( x &amp; 0x80 ) &gt;&gt; 7 ) )</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span>
<a name="l00040"></a>00040 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bitReverse[ 256 ] = {
<a name="l00041"></a>00041         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(   0 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(   1 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(   2 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(   3 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(   4 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(   5 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(   6 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(   7 ),
<a name="l00042"></a>00042         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(   8 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(   9 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  10 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  11 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  12 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  13 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  14 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  15 ),
<a name="l00043"></a>00043         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  16 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  17 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  18 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  19 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  20 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  21 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  22 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  23 ),
<a name="l00044"></a>00044         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  24 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  25 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  26 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  27 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  28 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  29 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  30 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  31 ),
<a name="l00045"></a>00045         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  32 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  33 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  34 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  35 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  36 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  37 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  38 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  39 ),
<a name="l00046"></a>00046         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  40 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  41 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  42 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  43 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  44 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  45 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  46 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  47 ),
<a name="l00047"></a>00047         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  48 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  49 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  50 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  51 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  52 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  53 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  54 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  55 ),
<a name="l00048"></a>00048         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  56 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  57 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  58 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  59 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  60 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  61 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  62 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  63 ),
<a name="l00049"></a>00049         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  64 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  65 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  66 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  67 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  68 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  69 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  70 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  71 ),
<a name="l00050"></a>00050         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  72 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  73 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  74 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  75 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  76 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  77 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  78 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  79 ),
<a name="l00051"></a>00051         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  80 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  81 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  82 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  83 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  84 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  85 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  86 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  87 ),
<a name="l00052"></a>00052         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  88 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  89 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  90 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  91 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  92 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  93 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  94 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  95 ),
<a name="l00053"></a>00053         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  96 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  97 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  98 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>(  99 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 100 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 101 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 102 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 103 ),
<a name="l00054"></a>00054         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 104 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 105 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 106 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 107 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 108 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 109 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 110 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 111 ),
<a name="l00055"></a>00055         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 112 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 113 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 114 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 115 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 116 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 117 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 118 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 119 ),
<a name="l00056"></a>00056         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 120 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 121 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 122 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 123 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 124 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 125 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 126 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 127 ),
<a name="l00057"></a>00057         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 128 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 129 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 130 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 131 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 132 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 133 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 134 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 135 ),
<a name="l00058"></a>00058         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 136 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 137 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 138 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 139 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 140 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 141 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 142 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 143 ),
<a name="l00059"></a>00059         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 144 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 145 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 146 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 147 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 148 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 149 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 150 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 151 ),
<a name="l00060"></a>00060         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 152 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 153 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 154 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 155 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 156 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 157 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 158 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 159 ),
<a name="l00061"></a>00061         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 160 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 161 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 162 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 163 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 164 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 165 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 166 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 167 ),
<a name="l00062"></a>00062         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 168 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 169 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 170 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 171 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 172 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 173 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 174 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 175 ),
<a name="l00063"></a>00063         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 176 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 177 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 178 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 179 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 180 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 181 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 182 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 183 ),
<a name="l00064"></a>00064         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 184 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 185 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 186 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 187 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 188 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 189 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 190 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 191 ),
<a name="l00065"></a>00065         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 192 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 193 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 194 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 195 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 196 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 197 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 198 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 199 ),
<a name="l00066"></a>00066         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 200 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 201 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 202 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 203 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 204 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 205 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 206 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 207 ),
<a name="l00067"></a>00067         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 208 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 209 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 210 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 211 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 212 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 213 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 214 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 215 ),
<a name="l00068"></a>00068         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 216 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 217 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 218 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 219 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 220 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 221 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 222 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 223 ),
<a name="l00069"></a>00069         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 224 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 225 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 226 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 227 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 228 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 229 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 230 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 231 ),
<a name="l00070"></a>00070         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 232 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 233 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 234 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 235 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 236 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 237 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 238 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 239 ),
<a name="l00071"></a>00071         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 240 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 241 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 242 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 243 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 244 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 245 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 246 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 247 ),
<a name="l00072"></a>00072         <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 248 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 249 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 250 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 251 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 252 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 253 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 254 ), <a class="code" href="_u_huffman_8cpp.html#2fb48dddfe1fdced40782c4e62530673">REV</a>( 255 ),
<a name="l00073"></a>00073 };
<a name="l00074"></a>00074 
<a name="l00075"></a>00075 <span class="comment">//**********************************************************</span>
<a name="l00077"></a>00077 <span class="comment"></span><span class="comment">//**********************************************************</span>
<a name="l00078"></a>00078 
<a name="l00079"></a>00079 <span class="comment">//==========================================================</span>
<a name="l00081"></a>00081 <span class="comment"></span><span class="comment">//==========================================================</span>
<a name="l00082"></a>00082 
<a name="l00083"></a>00083 <span class="comment">//----------------------------------------------------------</span>
<a name="l00084"></a><a class="code" href="class_u_huffman.html#1f62da0268315dfc2699b2998bfbdfd4">00084</a> <a class="code" href="class_u_huffman.html#1f62da0268315dfc2699b2998bfbdfd4" title="class UHuffman">UHuffman::UHuffman</a>()
<a name="l00085"></a>00085 : _compDst( 0 )
<a name="l00086"></a>00086 , _decompSrc( 0, 0 )
<a name="l00087"></a>00087 {
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 }
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 <span class="comment">//----------------------------------------------------------</span>
<a name="l00092"></a><a class="code" href="class_u_huffman.html#551d4efdc547d787e21ce00df8d9620b">00092</a> <a class="code" href="class_u_huffman.html#551d4efdc547d787e21ce00df8d9620b">UHuffman::~UHuffman</a>()
<a name="l00093"></a>00093 {
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 }
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 
<a name="l00098"></a>00098 <span class="comment">//==========================================================</span>
<a name="l00100"></a>00100 <span class="comment"></span><span class="comment">//==========================================================</span>
<a name="l00101"></a>00101 
<a name="l00102"></a>00102 <span class="comment">//----------------------------------------------------------</span>
<a name="l00103"></a>00103 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00104"></a><a class="code" href="class_u_huffman.html#b67d54176bba1e872cbd7f5cf1f7da97">00104</a> <a class="code" href="class_u_huffman.html#b67d54176bba1e872cbd7f5cf1f7da97" title="public methods">UHuffman::Compress</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* result, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* codeLengths, <span class="keyword">const</span> <span class="keywordtype">void</span>* srcData,
<a name="l00105"></a>00105                                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> srcSize )
<a name="l00106"></a>00106 {
<a name="l00108"></a>00108         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* <a class="code" href="glext_8h.html#72e0fdf0f845ded60b1fada9e9195cd7">src</a> = ( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* )srcData;
<a name="l00109"></a>00109 
<a name="l00111"></a>00111         <a class="code" href="class_u_huffman.html#bb7d56fc7fe5ac6c8176dcec7e33fb16" title="compression methods">CalcCodeLengths</a>( codeLengths, src, srcSize );
<a name="l00112"></a>00112 
<a name="l00114"></a>00114         <a class="code" href="class_u_huffman.html#40bee73e851e01e05190575b1e11e4bd" title="sets the destination buffer for bit stream compression.">SetCompStream</a>( result, codeLengths );
<a name="l00115"></a>00115 
<a name="l00117"></a>00117         <span class="keywordflow">while</span> ( srcSize-- &gt; 0 )
<a name="l00118"></a>00118                 <a class="code" href="class_u_huffman.html#0eda249aa726754bc2c936f81d38dd7f" title="writes a value to the stream.">WriteValue</a>( *src++ );
<a name="l00119"></a>00119 
<a name="l00121"></a>00121         <span class="keywordflow">return</span> <a class="code" href="class_u_huffman.html#516c71caadbb3ae69cff3d66453c140f">FinishWriting</a>();
<a name="l00122"></a>00122 }
<a name="l00123"></a>00123 
<a name="l00124"></a>00124 <span class="comment">//----------------------------------------------------------</span>
<a name="l00125"></a>00125 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00126"></a><a class="code" href="class_u_huffman.html#346391382b61c9da44b8895bcd2ccf6b">00126</a> <a class="code" href="class_u_huffman.html#346391382b61c9da44b8895bcd2ccf6b">UHuffman::Decompress</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* result, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* codeLengths, <span class="keyword">const</span> <span class="keywordtype">void</span>* compressedData,
<a name="l00127"></a>00127                                           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> srcBits )
<a name="l00128"></a>00128 {
<a name="l00130"></a>00130         <a class="code" href="class_u_huffman.html#4724b209df72141b8f40cdff1ce67c0e">SetDecompStream</a>( codeLengths, ( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* )compressedData, srcBits );
<a name="l00131"></a>00131 
<a name="l00133"></a>00133         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* <a class="code" href="glext_8h.html#92034251bfd455d524a9b5610cddba00">dst</a> = result;
<a name="l00134"></a>00134         <span class="keywordflow">while</span> ( !<a class="code" href="class_u_huffman.html#7286b963c43a2fa051e7a9956dc54e67" title="returns true while there is more data to be read.">IsReadFinished</a>() )
<a name="l00135"></a>00135                 *dst++ = <a class="code" href="class_u_huffman.html#c7ca2b479e621b555778358d6b02aa11" title="decompresses a byte off of the current set bit stream.">ReadValue</a>();
<a name="l00136"></a>00136 
<a name="l00138"></a>00138         <span class="keywordflow">return</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> )( size_t )( dst - result );
<a name="l00139"></a>00139 }
<a name="l00140"></a>00140 
<a name="l00141"></a>00141 <span class="comment">//----------------------------------------------------------</span>
<a name="l00142"></a>00142 <span class="keywordtype">void</span>
<a name="l00143"></a><a class="code" href="class_u_huffman.html#bb7d56fc7fe5ac6c8176dcec7e33fb16">00143</a> <a class="code" href="class_u_huffman.html#bb7d56fc7fe5ac6c8176dcec7e33fb16" title="compression methods">UHuffman::CalcCodeLengths</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* codeLengths, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* srcData,
<a name="l00144"></a>00144                                                    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> srcSize )
<a name="l00145"></a>00145 {
<a name="l00148"></a>00148         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> scores[ 256 ];
<a name="l00149"></a>00149         <a class="code" href="common__afx_8h.html#9f04579206286b6dc8c9708063450144" title="memory functions.">MemSet</a>( scores, 0, <span class="keyword">sizeof</span>( scores ) );
<a name="l00150"></a>00150 
<a name="l00152"></a>00152         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; srcSize; ++i )
<a name="l00153"></a>00153                 scores[ srcData[ i ] ] += 1;
<a name="l00154"></a>00154 
<a name="l00157"></a>00157         <a class="code" href="class_u_huffman.html#bb7d56fc7fe5ac6c8176dcec7e33fb16" title="compression methods">CalcCodeLengths</a>( codeLengths, scores );
<a name="l00158"></a>00158 }
<a name="l00159"></a>00159 
<a name="l00160"></a>00160 <span class="comment">//----------------------------------------------------------</span>
<a name="l00161"></a>00161 <span class="keywordtype">void</span>
<a name="l00162"></a><a class="code" href="class_u_huffman.html#21fec644cfad4256adf8a14564945467">00162</a> <a class="code" href="class_u_huffman.html#bb7d56fc7fe5ac6c8176dcec7e33fb16" title="compression methods">UHuffman::CalcCodeLengths</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* codeLengths, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* scores )
<a name="l00163"></a>00163 {
<a name="l00166"></a>00166 
<a name="l00169"></a>00169 
<a name="l00170"></a>00170         <span class="keyword">struct </span>SNodeCmp
<a name="l00171"></a>00171         {
<a name="l00172"></a>00172                 <span class="keywordtype">bool</span> operator () ( <span class="keyword">const</span> <a class="code" href="struct_s_node.html" title="class header.">SNode</a>* lhs, <span class="keyword">const</span> <a class="code" href="struct_s_node.html" title="class header.">SNode</a>* rhs )<span class="keyword"> const           </span>{       <span class="keywordflow">return</span> ( lhs-&gt;<a class="code" href="struct_s_node.html#fdf34ae214ee5ba96cbdefd552dfbd67">score</a> &lt; rhs-&gt;<a class="code" href="struct_s_node.html#fdf34ae214ee5ba96cbdefd552dfbd67">score</a> );     }
<a name="l00173"></a>00173                 <span class="keywordtype">bool</span> operator () ( <span class="keyword">const</span> <a class="code" href="struct_s_node.html" title="class header.">SNode</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="struct_s_node.html" title="class header.">SNode</a>&amp; rhs )<span class="keyword"> const           </span>{       <span class="keywordflow">return</span> ( lhs.<a class="code" href="struct_s_node.html#fdf34ae214ee5ba96cbdefd552dfbd67">score</a> &gt; rhs.<a class="code" href="struct_s_node.html#fdf34ae214ee5ba96cbdefd552dfbd67">score</a> );       }
<a name="l00174"></a>00174         };
<a name="l00175"></a>00175 
<a name="l00176"></a>00176         <a class="code" href="struct_s_node.html" title="class header.">SNode</a> nodes[ 511 ];
<a name="l00177"></a>00177         <a class="code" href="struct_s_node.html" title="class header.">SNode</a>* leaves = nodes;
<a name="l00178"></a>00178         <a class="code" href="struct_s_node.html" title="class header.">SNode</a>* branches = nodes + 256;
<a name="l00179"></a>00179 
<a name="l00181"></a>00181         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 256; ++i )
<a name="l00182"></a>00182         {
<a name="l00183"></a>00183                 leaves[ i ].<a class="code" href="struct_s_node.html#2089f30eda8aa96bbde23af8e2aa53d2">value</a> = ( <span class="keywordtype">unsigned</span> char )i;
<a name="l00184"></a>00184                 leaves[ i ].<a class="code" href="struct_s_node.html#fdf34ae214ee5ba96cbdefd552dfbd67">score</a> = scores[ i ];
<a name="l00185"></a>00185         }
<a name="l00186"></a>00186 
<a name="l00188"></a>00188         std::sort( leaves, leaves + 256, SNodeCmp() );
<a name="l00189"></a>00189 
<a name="l00191"></a>00191         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nodeCount = 0;
<a name="l00192"></a>00192         <span class="keywordflow">while</span> ( leaves[ nodeCount ].score &gt; 0 )
<a name="l00193"></a>00193                 ++nodeCount;
<a name="l00194"></a>00194 
<a name="l00196"></a>00196         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = nodeCount; i &lt; 256; ++i )
<a name="l00197"></a>00197                 codeLengths[ leaves[ i ].<a class="code" href="glext_8h.html#6a4f8a1a444e9080b297963b3db29fe0">value</a> ] = 0;
<a name="l00198"></a>00198 
<a name="l00200"></a>00200         <span class="keywordflow">if</span> ( nodeCount == 1 )
<a name="l00201"></a>00201         {
<a name="l00202"></a>00202                 codeLengths[ leaves[ 0 ].<a class="code" href="struct_s_node.html#2089f30eda8aa96bbde23af8e2aa53d2">value</a> ] = 1;
<a name="l00203"></a>00203                 <span class="keywordflow">return</span>;
<a name="l00204"></a>00204         }
<a name="l00205"></a>00205 
<a name="l00207"></a>00207         std::multiset&lt; SNode*, SNodeCmp &gt; queue;
<a name="l00208"></a>00208         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; nodeCount; ++i )
<a name="l00209"></a>00209                 queue.insert( leaves + i );
<a name="l00210"></a>00210 
<a name="l00212"></a>00212         <span class="keywordflow">while</span> ( queue.size() &gt; 1 )
<a name="l00213"></a>00213         {
<a name="l00215"></a>00215                 <a class="code" href="struct_s_node.html" title="class header.">SNode</a>* <a class="code" href="glext_8h.html#85b8f6c07fbc1fb5d77c2ae090f21995">left</a> = *queue.begin();
<a name="l00216"></a>00216                 left-&gt;<a class="code" href="struct_s_node.html#34a7a4584233ff71a079c7cc8af0d540" title="internal node data.">parent</a> = branches;
<a name="l00217"></a>00217                 queue.erase( queue.begin() );
<a name="l00218"></a>00218 
<a name="l00220"></a>00220                 <a class="code" href="struct_s_node.html" title="class header.">SNode</a>* <a class="code" href="glext_8h.html#5ffadbbacc6b89cf6218bc43b384d3fe">right</a> = *queue.begin();
<a name="l00221"></a>00221                 right-&gt;<a class="code" href="struct_s_node.html#34a7a4584233ff71a079c7cc8af0d540" title="internal node data.">parent</a> = branches;
<a name="l00222"></a>00222                 queue.erase( queue.begin() );
<a name="l00223"></a>00223 
<a name="l00225"></a>00225                 branches-&gt;<a class="code" href="struct_s_node.html#fdf34ae214ee5ba96cbdefd552dfbd67">score</a> = left-&gt;<a class="code" href="struct_s_node.html#fdf34ae214ee5ba96cbdefd552dfbd67">score</a> + right-&gt;<a class="code" href="struct_s_node.html#fdf34ae214ee5ba96cbdefd552dfbd67">score</a>;
<a name="l00226"></a>00226 
<a name="l00228"></a>00228                 queue.insert( branches++ );
<a name="l00229"></a>00229         }
<a name="l00230"></a>00230         <a class="code" href="struct_s_node.html" title="class header.">SNode</a>* root = *queue.begin();
<a name="l00231"></a>00231 
<a name="l00233"></a>00233         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; nodeCount; ++i )
<a name="l00234"></a>00234         {
<a name="l00237"></a>00237                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="glext_8h.html#2ba89f9e8d669bfad57028ce780865cd">len</a> = 0;
<a name="l00238"></a>00238                 <a class="code" href="struct_s_node.html" title="class header.">SNode</a>* cur = leaves + i;
<a name="l00239"></a>00239                 <span class="keywordflow">while</span> ( cur != root )
<a name="l00240"></a>00240                 {
<a name="l00241"></a>00241                         ++len;
<a name="l00242"></a>00242                         cur = cur-&gt;<a class="code" href="struct_s_node.html#34a7a4584233ff71a079c7cc8af0d540" title="internal node data.">parent</a>;
<a name="l00243"></a>00243                 }
<a name="l00244"></a>00244 
<a name="l00247"></a>00247                 <a class="code" href="common__afx_8h.html#2630490ce4292ed6d05359d2957796b8">B_ASSERT</a>( len &lt;= 16 );
<a name="l00248"></a>00248 
<a name="l00250"></a>00250                 codeLengths[ leaves[ i ].<a class="code" href="struct_s_node.html#2089f30eda8aa96bbde23af8e2aa53d2">value</a> ] = ( <span class="keywordtype">unsigned</span> char )len;
<a name="l00251"></a>00251         }
<a name="l00252"></a>00252 }
<a name="l00253"></a>00253 
<a name="l00254"></a>00254 <span class="comment">//----------------------------------------------------------</span>
<a name="l00255"></a>00255 <span class="keywordtype">void</span>
<a name="l00256"></a><a class="code" href="class_u_huffman.html#40bee73e851e01e05190575b1e11e4bd">00256</a> <a class="code" href="class_u_huffman.html#40bee73e851e01e05190575b1e11e4bd" title="sets the destination buffer for bit stream compression.">UHuffman::SetCompStream</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* compressedData, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* codeLengths )
<a name="l00257"></a>00257 {
<a name="l00259"></a>00259         <a class="code" href="class_u_huffman.html#9597786e7e70571b8d790728380b71ac">SetCompCodeLengths</a>( codeLengths );
<a name="l00260"></a>00260 
<a name="l00262"></a>00262         <a class="code" href="class_u_huffman.html#9787e1690a35cb0338b9225a2699b01e">SetCompStreamFast</a>( compressedData );
<a name="l00263"></a>00263 }
<a name="l00264"></a>00264 
<a name="l00265"></a>00265 <span class="comment">//----------------------------------------------------------</span>
<a name="l00266"></a>00266 <span class="keywordtype">void</span>
<a name="l00267"></a><a class="code" href="class_u_huffman.html#9597786e7e70571b8d790728380b71ac">00267</a> <a class="code" href="class_u_huffman.html#9597786e7e70571b8d790728380b71ac">UHuffman::SetCompCodeLengths</a>( <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* codeLengths )
<a name="l00268"></a>00268 {
<a name="l00270"></a>00270         BuildCompTables( codeLengths );
<a name="l00271"></a>00271 }
<a name="l00272"></a>00272 
<a name="l00273"></a>00273 <span class="comment">//----------------------------------------------------------</span>
<a name="l00274"></a>00274 <span class="keywordtype">void</span>
<a name="l00275"></a><a class="code" href="class_u_huffman.html#9787e1690a35cb0338b9225a2699b01e">00275</a> <a class="code" href="class_u_huffman.html#9787e1690a35cb0338b9225a2699b01e">UHuffman::SetCompStreamFast</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* compressedData )
<a name="l00276"></a>00276 {
<a name="l00278"></a>00278         _compDst.<a class="code" href="class_u_bit_writer.html#22c488a1b7f27b4e4be45fa9048746fb" title="resets the writer and assigns a new output stream.">Reset</a>( compressedData );
<a name="l00279"></a>00279 }
<a name="l00280"></a>00280 
<a name="l00281"></a>00281 <span class="comment">//----------------------------------------------------------</span>
<a name="l00282"></a>00282 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00283"></a><a class="code" href="class_u_huffman.html#6983a5b88a551be8221fcd69b1dfa6b7">00283</a> <a class="code" href="class_u_huffman.html#6983a5b88a551be8221fcd69b1dfa6b7">UHuffman::GetValueLen</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="glext_8h.html#6a4f8a1a444e9080b297963b3db29fe0">value</a> )<span class="keyword"> const</span>
<a name="l00284"></a>00284 <span class="keyword"></span>{
<a name="l00285"></a>00285         <span class="keywordflow">return</span> _cmpLenTable[ value ];
<a name="l00286"></a>00286 }
<a name="l00287"></a>00287 
<a name="l00288"></a>00288 <span class="comment">//----------------------------------------------------------</span>
<a name="l00289"></a>00289 <span class="keywordtype">void</span>
<a name="l00290"></a><a class="code" href="class_u_huffman.html#0eda249aa726754bc2c936f81d38dd7f">00290</a> <a class="code" href="class_u_huffman.html#0eda249aa726754bc2c936f81d38dd7f" title="writes a value to the stream.">UHuffman::WriteValue</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="glext_8h.html#6a4f8a1a444e9080b297963b3db29fe0">value</a> )
<a name="l00291"></a>00291 {
<a name="l00293"></a>00293         _compDst.<a class="code" href="class_u_bit_writer.html#c13e9a7c145b428ff95d716658bea5bb">WriteBits</a>( _cmpCodes[ value ], _cmpLenTable[ value ] );
<a name="l00294"></a>00294 }
<a name="l00295"></a>00295 
<a name="l00296"></a>00296 <span class="comment">//----------------------------------------------------------</span>
<a name="l00297"></a>00297 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00298"></a><a class="code" href="class_u_huffman.html#516c71caadbb3ae69cff3d66453c140f">00298</a> <a class="code" href="class_u_huffman.html#516c71caadbb3ae69cff3d66453c140f">UHuffman::FinishWriting</a>()
<a name="l00299"></a>00299 {
<a name="l00301"></a>00301         _compDst.<a class="code" href="class_u_bit_writer.html#e5a5a7cd5aaf0f4a9b91331d94825a33">Finish</a>();
<a name="l00302"></a>00302 
<a name="l00304"></a>00304         <span class="keywordflow">return</span> _compDst.<a class="code" href="class_u_bit_writer.html#f6f57344e33cbb035fab173f200d2f66" title="returns the total number of bits written.">GetBitCount</a>();
<a name="l00305"></a>00305 }
<a name="l00306"></a>00306 
<a name="l00307"></a>00307 <span class="comment">//----------------------------------------------------------</span>
<a name="l00308"></a>00308 <span class="keywordtype">void</span>
<a name="l00309"></a><a class="code" href="class_u_huffman.html#4724b209df72141b8f40cdff1ce67c0e">00309</a> <a class="code" href="class_u_huffman.html#4724b209df72141b8f40cdff1ce67c0e">UHuffman::SetDecompStream</a>( <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* codeLengths, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* compressedData,
<a name="l00310"></a>00310                                                    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> srcBitCount )
<a name="l00311"></a>00311 {
<a name="l00313"></a>00313         <a class="code" href="class_u_huffman.html#96d45824c8002b45be38b9cf6ce36e02">SetDecompCodeLengths</a>( codeLengths );
<a name="l00314"></a>00314 
<a name="l00316"></a>00316         <a class="code" href="class_u_huffman.html#a6ec33a164afdf0b2dc7809a44603953">SetDecompStreamFast</a>( compressedData, srcBitCount );
<a name="l00317"></a>00317 }
<a name="l00318"></a>00318 
<a name="l00319"></a>00319 <span class="comment">//----------------------------------------------------------</span>
<a name="l00320"></a>00320 <span class="keywordtype">void</span>
<a name="l00321"></a><a class="code" href="class_u_huffman.html#96d45824c8002b45be38b9cf6ce36e02">00321</a> <a class="code" href="class_u_huffman.html#96d45824c8002b45be38b9cf6ce36e02">UHuffman::SetDecompCodeLengths</a>( <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* codeLengths )
<a name="l00322"></a>00322 {
<a name="l00324"></a>00324         BuildDecompTables( codeLengths );
<a name="l00325"></a>00325 }
<a name="l00326"></a>00326 
<a name="l00327"></a>00327 <span class="comment">//----------------------------------------------------------</span>
<a name="l00328"></a>00328 <span class="keywordtype">void</span>
<a name="l00329"></a><a class="code" href="class_u_huffman.html#bd37ac1f5c41a6e288d6068ad8e6bbf4">00329</a> <a class="code" href="class_u_huffman.html#bd37ac1f5c41a6e288d6068ad8e6bbf4">UHuffman::BuildDecompFastTables</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* symTable, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* lenTable, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* rareSymTable,
<a name="l00330"></a>00330                                                                  <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>* maxCodeTable, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* rareCodeOffsetTable,
<a name="l00331"></a>00331                                                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* codeLengths )
<a name="l00332"></a>00332 {
<a name="l00334"></a>00334         BuildDecompTables( codeLengths );
<a name="l00335"></a>00335 
<a name="l00337"></a>00337         <a class="code" href="common__afx_8cpp.html#b4b15928b71967d4c4eb8c12c3108643">MemCopy</a>( symTable, _symTable, 256 );
<a name="l00338"></a>00338         <a class="code" href="common__afx_8cpp.html#b4b15928b71967d4c4eb8c12c3108643">MemCopy</a>( lenTable, _lenTable, 256 );
<a name="l00339"></a>00339         <a class="code" href="common__afx_8cpp.html#b4b15928b71967d4c4eb8c12c3108643">MemCopy</a>( rareSymTable, _rareSymTable, 512 );
<a name="l00340"></a>00340         <a class="code" href="common__afx_8cpp.html#b4b15928b71967d4c4eb8c12c3108643">MemCopy</a>( maxCodeTable, _maxCodeTable, 17 * <span class="keyword">sizeof</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> ) );
<a name="l00341"></a>00341         <a class="code" href="common__afx_8cpp.html#b4b15928b71967d4c4eb8c12c3108643">MemCopy</a>( rareCodeOffsetTable, _rareCodeOffsetTable, 17 * <span class="keyword">sizeof</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> ) );
<a name="l00342"></a>00342 }
<a name="l00343"></a>00343 
<a name="l00344"></a>00344 <span class="comment">//----------------------------------------------------------</span>
<a name="l00345"></a>00345 <span class="keywordtype">void</span>
<a name="l00346"></a><a class="code" href="class_u_huffman.html#3b8362f5138b30083836f777baa7e792">00346</a> <a class="code" href="class_u_huffman.html#3b8362f5138b30083836f777baa7e792" title="sets the tables used for decompression.">UHuffman::SetDecompFastTables</a>( <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* symTable, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* lenTable,
<a name="l00347"></a>00347                                                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* rareSymTable, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>* maxCodeTable,
<a name="l00348"></a>00348                                                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* rareCodeOffsetTable )
<a name="l00349"></a>00349 {
<a name="l00351"></a>00351         <a class="code" href="common__afx_8cpp.html#b4b15928b71967d4c4eb8c12c3108643">MemCopy</a>( _symTable, symTable, 256 );
<a name="l00352"></a>00352         <a class="code" href="common__afx_8cpp.html#b4b15928b71967d4c4eb8c12c3108643">MemCopy</a>( _lenTable, lenTable, 256 );
<a name="l00353"></a>00353         <a class="code" href="common__afx_8cpp.html#b4b15928b71967d4c4eb8c12c3108643">MemCopy</a>( _rareSymTable, rareSymTable, 512 );
<a name="l00354"></a>00354         <a class="code" href="common__afx_8cpp.html#b4b15928b71967d4c4eb8c12c3108643">MemCopy</a>( _maxCodeTable, maxCodeTable, 17 * <span class="keyword">sizeof</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> ) );
<a name="l00355"></a>00355         <a class="code" href="common__afx_8cpp.html#b4b15928b71967d4c4eb8c12c3108643">MemCopy</a>( _rareCodeOffsetTable, rareCodeOffsetTable, 17 * <span class="keyword">sizeof</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> ) );
<a name="l00356"></a>00356 }
<a name="l00357"></a>00357 
<a name="l00358"></a>00358 <span class="comment">//----------------------------------------------------------</span>
<a name="l00359"></a>00359 <span class="keywordtype">void</span>
<a name="l00360"></a><a class="code" href="class_u_huffman.html#a6ec33a164afdf0b2dc7809a44603953">00360</a> <a class="code" href="class_u_huffman.html#a6ec33a164afdf0b2dc7809a44603953">UHuffman::SetDecompStreamFast</a>( <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* compressedData, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> srcBitCount )
<a name="l00361"></a>00361 {
<a name="l00362"></a>00362         _decompSrc.<a class="code" href="class_u_bit_reader.html#bfd4df4797cd828c904ae5fff3153499" title="resets the reader.">Reset</a>( compressedData, srcBitCount );
<a name="l00363"></a>00363 }
<a name="l00364"></a>00364 
<a name="l00365"></a>00365 <span class="comment">//----------------------------------------------------------</span>
<a name="l00366"></a>00366 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>
<a name="l00367"></a><a class="code" href="class_u_huffman.html#c7ca2b479e621b555778358d6b02aa11">00367</a> <a class="code" href="class_u_huffman.html#c7ca2b479e621b555778358d6b02aa11" title="decompresses a byte off of the current set bit stream.">UHuffman::ReadValue</a>()
<a name="l00368"></a>00368 {
<a name="l00370"></a>00370         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="glext_8h.html#6a4f8a1a444e9080b297963b3db29fe0">value</a> = _decompSrc.<a class="code" href="class_u_bit_reader.html#4744716f48876dde16fc77d995874dfe">PeekBits</a>( 8 );
<a name="l00371"></a>00371 
<a name="l00373"></a>00373         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> codeLen = _lenTable[ value ];
<a name="l00374"></a>00374         <span class="keywordflow">if</span> ( codeLen != 0 )
<a name="l00375"></a>00375         {
<a name="l00378"></a>00378                 _decompSrc.<a class="code" href="class_u_bit_reader.html#1d593ed1bb42821586c7ab7f82cabca6">SkipBits</a>( codeLen );
<a name="l00379"></a>00379                 <span class="keywordflow">return</span> _symTable[ value ];
<a name="l00380"></a>00380         }
<a name="l00381"></a>00381 
<a name="l00383"></a>00383         value = _decompSrc.<a class="code" href="class_u_bit_reader.html#4744716f48876dde16fc77d995874dfe">PeekBits</a>( 16 );
<a name="l00384"></a>00384 
<a name="l00386"></a>00386         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> revValue = ReverseBits( ( <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> )value );
<a name="l00387"></a>00387         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bitCount = 8;
<a name="l00388"></a>00388         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 9; i &lt;= 16; ++i )
<a name="l00389"></a>00389                 bitCount += ( revValue &lt;= _maxCodeTable[ i ] );
<a name="l00390"></a>00390 
<a name="l00392"></a>00392         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> code = revValue &gt;&gt; ( 16 - bitCount );
<a name="l00393"></a>00393 
<a name="l00395"></a>00395         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="glext_8h.html#a782f3aea23e3c30029c811241dc2c82">offset</a> = _rareCodeOffsetTable[ bitCount ];
<a name="l00396"></a>00396 
<a name="l00398"></a>00398         _decompSrc.<a class="code" href="class_u_bit_reader.html#1d593ed1bb42821586c7ab7f82cabca6">SkipBits</a>( bitCount );
<a name="l00399"></a>00399 
<a name="l00401"></a>00401         <span class="keywordflow">return</span> _rareSymTable[ offset + code ];
<a name="l00402"></a>00402 }
<a name="l00403"></a>00403 
<a name="l00404"></a>00404 <span class="comment">//----------------------------------------------------------</span>
<a name="l00405"></a>00405 <span class="keywordtype">bool</span>
<a name="l00406"></a><a class="code" href="class_u_huffman.html#7286b963c43a2fa051e7a9956dc54e67">00406</a> <a class="code" href="class_u_huffman.html#7286b963c43a2fa051e7a9956dc54e67" title="returns true while there is more data to be read.">UHuffman::IsReadFinished</a>()
<a name="l00407"></a>00407 {
<a name="l00410"></a>00410         <span class="keywordflow">return</span> _decompSrc.<a class="code" href="class_u_bit_reader.html#c16aa31ff853ab9423122d02e6e6e451">IsFinished</a>();
<a name="l00411"></a>00411 }
<a name="l00412"></a>00412 
<a name="l00413"></a>00413 
<a name="l00414"></a>00414 <span class="comment">//==========================================================</span>
<a name="l00416"></a>00416 <span class="comment"></span><span class="comment">//==========================================================</span>
<a name="l00417"></a>00417 
<a name="l00418"></a>00418 <span class="comment">//----------------------------------------------------------</span>
<a name="l00419"></a>00419 <span class="keywordtype">bool</span>
<a name="l00420"></a>00420 UHuffman::DicSort( <span class="keyword">const</span> SDicEntry&amp; lhs, <span class="keyword">const</span> SDicEntry&amp; rhs )
<a name="l00421"></a>00421 {
<a name="l00423"></a>00423         <span class="keywordflow">if</span> ( lhs.codeLen == rhs.codeLen )
<a name="l00424"></a>00424                 <span class="keywordflow">return</span> lhs.value &lt; rhs.value;
<a name="l00425"></a>00425 
<a name="l00427"></a>00427         <span class="keywordflow">return</span> lhs.codeLen &gt; rhs.codeLen;
<a name="l00428"></a>00428 }
<a name="l00429"></a>00429 
<a name="l00430"></a>00430 <span class="comment">//----------------------------------------------------------</span>
<a name="l00431"></a>00431 <span class="keywordtype">void</span>
<a name="l00432"></a>00432 UHuffman::BuildDic( SDicEntry* dic, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* codeLengths )
<a name="l00433"></a>00433 {
<a name="l00435"></a>00435         dic[ 256 ].codeLen = 0;
<a name="l00436"></a>00436 
<a name="l00438"></a>00438         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> symCount = 0;
<a name="l00439"></a>00439         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 256; ++i )
<a name="l00440"></a>00440         {
<a name="l00442"></a>00442                 dic[ i ].value = i;
<a name="l00443"></a>00443                 dic[ i ].codeLen = codeLengths[ i ];
<a name="l00444"></a>00444                 dic[ i ].code = 0;
<a name="l00445"></a>00445         }
<a name="l00446"></a>00446 
<a name="l00448"></a>00448         std::sort( dic, dic + 256, DicSort );
<a name="l00449"></a>00449 
<a name="l00451"></a>00451         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> code = 0;
<a name="l00452"></a>00452         SDicEntry* cur = dic;
<a name="l00453"></a>00453         <span class="keywordflow">while</span> ( cur-&gt;codeLen &gt; 0 )
<a name="l00454"></a>00454         {
<a name="l00456"></a>00456                 cur-&gt;code = 0;
<a name="l00457"></a>00457                 <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <a class="code" href="glext_8h.html#72e0fdf0f845ded60b1fada9e9195cd7">src</a> = code;
<a name="l00458"></a>00458                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = cur-&gt;codeLen - 1;
<a name="l00459"></a>00459                 <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; cur-&gt;codeLen; ++i, --j, src &gt;&gt;= 1 )
<a name="l00460"></a>00460                         cur-&gt;code |= ( src &amp; 1 ) &lt;&lt; j;
<a name="l00461"></a>00461 
<a name="l00463"></a>00463                 code += 1;
<a name="l00464"></a>00464 
<a name="l00466"></a>00466                 code &gt;&gt;= ( cur[ 0 ].codeLen - cur[ 1 ].codeLen );
<a name="l00467"></a>00467 
<a name="l00469"></a>00469                 ++cur;
<a name="l00470"></a>00470         }
<a name="l00471"></a>00471 <span class="preprocessor">#if 0</span>
<a name="l00473"></a>00473 <span class="preprocessor">        size_t count = cur - dic;</span>
<a name="l00474"></a>00474 <span class="preprocessor"></span>        <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="_g_l_8h.html#10b284d589000663becfbc6867a3a9f7">count</a>; ++i )
<a name="l00475"></a>00475         {
<a name="l00476"></a>00476                 <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = i + 1; j &lt; count; ++j )
<a name="l00477"></a>00477                 {
<a name="l00478"></a>00478                         <a class="code" href="common__afx_8h.html#2630490ce4292ed6d05359d2957796b8">B_ASSERT</a>( ( dic[ i ].code &amp; dic[ j ].code ) != dic[ j ].code );
<a name="l00479"></a>00479                 }
<a name="l00480"></a>00480         }
<a name="l00481"></a>00481 <span class="preprocessor">#endif</span>
<a name="l00482"></a>00482 <span class="preprocessor"></span>}
<a name="l00483"></a>00483 
<a name="l00484"></a>00484 <span class="comment">//----------------------------------------------------------</span>
<a name="l00485"></a>00485 <span class="keywordtype">void</span>
<a name="l00486"></a>00486 UHuffman::BuildCompTables( <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* codeLengths )
<a name="l00487"></a>00487 {
<a name="l00489"></a>00489         SDicEntry dic[ 257 ];
<a name="l00490"></a>00490         BuildDic( dic, codeLengths );
<a name="l00491"></a>00491 
<a name="l00493"></a>00493         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 256; ++i )
<a name="l00494"></a>00494         {
<a name="l00495"></a>00495                 _cmpCodes[ dic[ i ].value ] = dic[ i ].code;
<a name="l00496"></a>00496                 _cmpLenTable[ dic[ i ].value ] = dic[ i ].codeLen;
<a name="l00497"></a>00497         }
<a name="l00498"></a>00498 }
<a name="l00499"></a>00499 
<a name="l00500"></a>00500 <span class="comment">//----------------------------------------------------------</span>
<a name="l00501"></a>00501 <span class="keywordtype">void</span>
<a name="l00502"></a>00502 UHuffman::BuildDecompTables( <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* codeLengths )
<a name="l00503"></a>00503 {
<a name="l00505"></a>00505         SDicEntry dic[ 257 ];
<a name="l00506"></a>00506         BuildDic( dic, codeLengths );
<a name="l00507"></a>00507 
<a name="l00509"></a>00509         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 17; ++i )
<a name="l00510"></a>00510                 _maxCodeTable[ i ] = 0;
<a name="l00511"></a>00511 
<a name="l00513"></a>00513         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> justifiedCodes[ 256 ];
<a name="l00514"></a>00514         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 256; ++i )
<a name="l00515"></a>00515         {
<a name="l00517"></a>00517                 justifiedCodes[ i ] = ReverseBits( dic[ i ].code );
<a name="l00518"></a>00518                 _maxCodeTable[ dic[ i ].codeLen ] = <a class="code" href="common__afx_8h.html#dd09d155ffe827b203d3236b451752e7">Max</a>( _maxCodeTable[ dic[ i ].codeLen ], justifiedCodes[ i ] );
<a name="l00519"></a>00519 <span class="preprocessor">#if 0</span>
<a name="l00520"></a>00520 <span class="preprocessor"></span>                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> code = justifiedCodes[ i ]; 
<a name="l00521"></a>00521                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> codeLen = dic[ i ].codeLen;
<a name="l00522"></a>00522                 <a class="code" href="common__afx_8cpp.html#f1a1e0f08b49000974368246e5b97f84" title="debug output/console output function.">PrintF</a>( <span class="stringliteral">"0x%08X, %d\n"</span>, code, codeLen );
<a name="l00523"></a>00523 <span class="preprocessor">#endif</span>
<a name="l00524"></a>00524 <span class="preprocessor"></span>        }
<a name="l00525"></a>00525 
<a name="l00527"></a>00527         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 17; ++i )
<a name="l00528"></a>00528         {
<a name="l00529"></a>00529                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> extraBits = ( 1 &lt;&lt; ( 16 - i ) ) - 1;
<a name="l00530"></a>00530                 _maxCodeTable[ i ] |= extraBits;
<a name="l00531"></a>00531         }
<a name="l00532"></a>00532 
<a name="l00534"></a>00534         _rareCodeOffsetTable[ 16 ] = 0;
<a name="l00535"></a>00535         _rareCodeOffsetTable[ dic[ 0 ].codeLen ] = 0;
<a name="l00536"></a>00536         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> curCodeLength = dic[ 0 ].codeLen;
<a name="l00537"></a>00537         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> curCodeOffset = 0;
<a name="l00538"></a>00538         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> curMaxCode = 0;
<a name="l00539"></a>00539         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 256; ++i )
<a name="l00540"></a>00540         {
<a name="l00541"></a>00541                 SDicEntry&amp; curEntry = dic[ i ];
<a name="l00542"></a>00542                 <span class="keywordflow">if</span> ( curEntry.codeLen == 0 )
<a name="l00543"></a>00543                         <span class="keywordflow">continue</span>;
<a name="l00544"></a>00544 
<a name="l00546"></a>00546                 <span class="keywordflow">if</span> ( curEntry.codeLen &lt;= 8 )
<a name="l00547"></a>00547                 {
<a name="l00549"></a>00549                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> highBits = ( 8 - curEntry.codeLen );
<a name="l00550"></a>00550                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> valueCount = 1 &lt;&lt; highBits;
<a name="l00551"></a>00551                         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; valueCount; ++j )
<a name="l00552"></a>00552                         {
<a name="l00555"></a>00555                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="glext_8h.html#57f14e05b1900f16a2da82ade47d0c6d">index</a> = ( j &lt;&lt; curEntry.codeLen ) + curEntry.code;
<a name="l00556"></a>00556                                 _symTable[ index ] = curEntry.value;
<a name="l00557"></a>00557                                 _lenTable[ index ] = curEntry.codeLen;
<a name="l00558"></a>00558                         }
<a name="l00559"></a>00559                 }
<a name="l00560"></a>00560                 <span class="keywordflow">else</span>
<a name="l00561"></a>00561                 {
<a name="l00563"></a>00563                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="glext_8h.html#57f14e05b1900f16a2da82ade47d0c6d">index</a> = curEntry.code &amp; 0xFF;
<a name="l00564"></a>00564                         _lenTable[ index ] = 0;
<a name="l00565"></a>00565 
<a name="l00569"></a>00569                         <span class="keywordflow">if</span> ( curCodeLength != curEntry.codeLen )
<a name="l00570"></a>00570                         {
<a name="l00571"></a>00571                                 curCodeOffset += ( curMaxCode + 1 );
<a name="l00572"></a>00572                                 curCodeLength = curEntry.codeLen;
<a name="l00573"></a>00573                                 _rareCodeOffsetTable[ curCodeLength ] = curCodeOffset;
<a name="l00574"></a>00574                                 curMaxCode = 0;
<a name="l00575"></a>00575                         }
<a name="l00576"></a>00576 
<a name="l00578"></a>00578                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> code = ReverseBits( curEntry.code ) &gt;&gt; ( 16 - curCodeLength );
<a name="l00579"></a>00579                         curMaxCode = <a class="code" href="common__afx_8h.html#dd09d155ffe827b203d3236b451752e7">Max</a>( curMaxCode, code );
<a name="l00580"></a>00580 
<a name="l00582"></a>00582                         _rareSymTable[ curCodeOffset + code ] = curEntry.value;
<a name="l00583"></a>00583                 }
<a name="l00584"></a>00584         }
<a name="l00585"></a>00585 }
<a name="l00586"></a>00586 
<a name="l00587"></a>00587 <span class="comment">//----------------------------------------------------------</span>
<a name="l00588"></a>00588 <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>
<a name="l00589"></a>00589 UHuffman::ReverseBits( <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> src )
<a name="l00590"></a>00590 {
<a name="l00591"></a>00591         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <a class="code" href="glext_8h.html#92034251bfd455d524a9b5610cddba00">dst</a>;
<a name="l00592"></a>00592         dst = bitReverse[ src &amp; 0xFF ] &lt;&lt; 8;
<a name="l00593"></a>00593         dst |= bitReverse[ src &gt;&gt; 8 ];
<a name="l00594"></a>00594         <span class="keywordflow">return</span> dst;
<a name="l00595"></a>00595 }
<a name="l00596"></a>00596 
<a name="l00598"></a>00598 <span class="preprocessor">#if 0</span>
<a name="l00603"></a>00603 <span class="preprocessor">#define SCORE_BYTE_COUNT                1</span>
<a name="l00604"></a>00604 <span class="preprocessor"></span><span class="preprocessor">#define SCORE_BIT_COUNT                 8</span>
<a name="l00605"></a>00605 <span class="preprocessor"></span>
<a name="l00607"></a>00607 <span class="keyword">struct </span>STreeNode
<a name="l00608"></a>00608 {
<a name="l00609"></a>00609         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <a class="code" href="glext_8h.html#6a4f8a1a444e9080b297963b3db29fe0">value</a>;
<a name="l00610"></a>00610         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> score;
<a name="l00611"></a>00611         STreeNode* parent;
<a name="l00612"></a>00612         STreeNode* children[ 2 ];
<a name="l00613"></a>00613 };
<a name="l00614"></a>00614 
<a name="l00616"></a>00616 <span class="keyword">struct </span>SRareSymbol
<a name="l00617"></a>00617 {
<a name="l00618"></a>00618         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> symbol;
<a name="l00619"></a>00619         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> code;
<a name="l00620"></a>00620         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> codeLen;
<a name="l00621"></a>00621 };
<a name="l00622"></a>00622 
<a name="l00623"></a>00623 <span class="keywordtype">bool</span> RareSymbolSort( <span class="keyword">const</span> SRareSymbol&amp; lhs, <span class="keyword">const</span> SRareSymbol&amp; rhs )
<a name="l00624"></a>00624 {
<a name="l00625"></a>00625         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> lhsMask = lhs.code &amp; 0xFF;
<a name="l00626"></a>00626         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> rhsMask = rhs.code &amp; 0xFF;
<a name="l00627"></a>00627         <span class="keywordflow">if</span> ( lhsMask == rhsMask )
<a name="l00628"></a>00628         {
<a name="l00630"></a>00630                 <span class="keywordflow">if</span> ( lhs.codeLen == rhs.codeLen )
<a name="l00631"></a>00631                         <span class="keywordflow">return</span> lhs.code &lt; rhs.code;
<a name="l00632"></a>00632 
<a name="l00634"></a>00634                 <span class="keywordflow">return</span> lhs.codeLen &lt; rhs.codeLen;
<a name="l00635"></a>00635         }
<a name="l00636"></a>00636 
<a name="l00638"></a>00638         <span class="keywordflow">return</span> lhsMask &lt; rhsMask;
<a name="l00639"></a>00639 }
<a name="l00640"></a>00640 
<a name="l00642"></a>00642 <span class="keyword">class </span>ScoreSort
<a name="l00643"></a>00643 {
<a name="l00644"></a>00644 <span class="keyword">public</span>:
<a name="l00645"></a>00645         <span class="keywordtype">bool</span> operator() ( <span class="keyword">const</span> STreeNode* lhs, <span class="keyword">const</span> STreeNode* rhs )
<a name="l00646"></a>00646         {
<a name="l00647"></a>00647                 <span class="keywordflow">return</span> ( lhs-&gt;score &lt; rhs-&gt;score );
<a name="l00648"></a>00648         }
<a name="l00649"></a>00649 };
<a name="l00650"></a>00650 
<a name="l00653"></a>00653 <span class="keyword">static</span> STreeNode* BuildTree( STreeNode** nodes, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* minDepth = 0 );
<a name="l00654"></a>00654 <span class="keyword">static</span> <span class="keywordtype">void</span> BuildBitLengths( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* lengths, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* scores );
<a name="l00655"></a>00655 
<a name="l00656"></a>00656 <span class="comment">//**********************************************************</span>
<a name="l00658"></a>00658 <span class="comment"></span><span class="comment">//**********************************************************</span>
<a name="l00659"></a>00659 
<a name="l00660"></a>00660 <span class="comment">//==========================================================</span>
<a name="l00662"></a>00662 <span class="comment"></span><span class="comment">//==========================================================</span>
<a name="l00663"></a>00663 
<a name="l00664"></a>00664 <span class="comment">//----------------------------------------------------------</span>
<a name="l00665"></a>00665 <a class="code" href="class_u_huffman.html#1f62da0268315dfc2699b2998bfbdfd4" title="class UHuffman">UHuffman::UHuffman</a>()
<a name="l00666"></a>00666 : _bitStream( 0 )
<a name="l00667"></a>00667 , _bitCount( 0 )
<a name="l00668"></a>00668 , _ownBits( false )
<a name="l00669"></a>00669 {
<a name="l00670"></a>00670         
<a name="l00671"></a>00671 }
<a name="l00672"></a>00672 
<a name="l00673"></a>00673 <span class="comment">//----------------------------------------------------------</span>
<a name="l00674"></a>00674 <a class="code" href="class_u_huffman.html#551d4efdc547d787e21ce00df8d9620b">UHuffman::~UHuffman</a>()
<a name="l00675"></a>00675 {
<a name="l00676"></a>00676         <span class="keywordflow">if</span> ( _ownBits )
<a name="l00677"></a>00677                 <span class="keyword">delete</span>[] _bitStream;
<a name="l00678"></a>00678 }
<a name="l00679"></a>00679 
<a name="l00680"></a>00680 
<a name="l00681"></a>00681 <span class="comment">//==========================================================</span>
<a name="l00683"></a>00683 <span class="comment"></span><span class="comment">//==========================================================</span>
<a name="l00684"></a>00684 
<a name="l00685"></a>00685 <span class="comment">//----------------------------------------------------------</span>
<a name="l00686"></a>00686 <span class="keywordtype">void</span>
<a name="l00687"></a>00687 UHuffman::Encode( <span class="keyword">const</span> <span class="keywordtype">void</span>* srcData, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> srcSize )
<a name="l00688"></a>00688 {
<a name="l00690"></a>00690         STreeNode nodeData[ 513 ];
<a name="l00691"></a>00691         STreeNode* nodes[ 513 ];
<a name="l00692"></a>00692         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 513; ++i )
<a name="l00693"></a>00693         {
<a name="l00694"></a>00694                 nodeData[ i ].value = i;
<a name="l00695"></a>00695                 nodeData[ i ].score = 0;
<a name="l00696"></a>00696                 nodeData[ i ].children[ 0 ] = 0;
<a name="l00697"></a>00697                 nodeData[ i ].children[ 1 ] = 0;
<a name="l00698"></a>00698                 nodeData[ i ].parent = 0;
<a name="l00699"></a>00699                 nodes[ i ] = nodeData + i;
<a name="l00700"></a>00700         }
<a name="l00701"></a>00701 
<a name="l00704"></a>00704         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* src = ( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* )srcData;
<a name="l00705"></a>00705         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* <a class="code" href="_g_l_8h.html#432111147038972f06e049e18a837002">end</a> = src + srcSize;
<a name="l00706"></a>00706         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxScore = 0;
<a name="l00707"></a>00707         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> scores[ 256 ];
<a name="l00708"></a>00708         <a class="code" href="common__afx_8h.html#9f04579206286b6dc8c9708063450144" title="memory functions.">MemSet</a>( scores, 0, <span class="keyword">sizeof</span>( scores ) );
<a name="l00709"></a>00709         <span class="keywordflow">while</span> ( src != end )
<a name="l00710"></a>00710         {
<a name="l00712"></a>00712                 scores[ *src ] += 1;
<a name="l00713"></a>00713                 maxScore = <a class="code" href="common__afx_8h.html#dd09d155ffe827b203d3236b451752e7">Max</a>( scores[ *src++ ], maxScore );
<a name="l00714"></a>00714         }
<a name="l00715"></a>00715 
<a name="l00717"></a>00717         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> adjust = 0;
<a name="l00718"></a>00718         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="glext_8h.html#76b486a23d5da07752f89495cdaedcf4">maxCount</a> = <a class="code" href="common__afx_8h.html#df309c61a344cf812c926af221641f24">Log2</a>( maxScore ) + 1;
<a name="l00719"></a>00719         <span class="keywordflow">if</span> ( maxCount &gt; SCORE_BIT_COUNT )
<a name="l00720"></a>00720                 adjust = maxCount - SCORE_BIT_COUNT;
<a name="l00721"></a>00721 
<a name="l00723"></a>00723         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="glext_8h.html#bb269dedb7ad104274cc9f5c0c7285bc">mask</a> = ( 1 &lt;&lt; adjust ) - 1;
<a name="l00724"></a>00724         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 256; ++i )
<a name="l00725"></a>00725         {
<a name="l00726"></a>00726                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> roundUp = ( scores[ i ] &amp; mask ) != 0;
<a name="l00727"></a>00727                 scores[ i ] &gt;&gt;= adjust;
<a name="l00728"></a>00728                 scores[ i ] += roundUp;
<a name="l00729"></a>00729                 nodeData[ i ].score = ( <span class="keywordtype">unsigned</span> short )scores[ i ];
<a name="l00730"></a>00730         }
<a name="l00731"></a>00731 
<a name="l00733"></a>00733         STreeNode* root = BuildTree( nodes );
<a name="l00734"></a>00734 
<a name="l00737"></a>00737         _bitStream = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[ srcSize + 513 + 4 ];
<a name="l00738"></a>00738         _ownBits = <span class="keyword">true</span>;
<a name="l00739"></a>00739 
<a name="l00741"></a>00741         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bitIndex = 0;
<a name="l00742"></a>00742         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* <a class="code" href="glext_8h.html#92034251bfd455d524a9b5610cddba00">dst</a> = ( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* )_bitStream;
<a name="l00743"></a>00743 
<a name="l00744"></a>00744 <span class="preprocessor">#if SCORE_BYTE_COUNT == 1</span>
<a name="l00746"></a>00746 <span class="preprocessor">        unsigned int runLen = 0;</span>
<a name="l00747"></a>00747 <span class="preprocessor"></span>        <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 256; i += runLen )
<a name="l00748"></a>00748         {
<a name="l00750"></a>00750                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxLen = 256 - i;
<a name="l00751"></a>00751 
<a name="l00753"></a>00753                 runLen = 0;
<a name="l00754"></a>00754                 STreeNode* curNode = nodeData + i;
<a name="l00755"></a>00755                 STreeNode* laNode = curNode;
<a name="l00756"></a>00756                 <span class="keywordflow">while</span> ( maxLen-- &gt; 0 &amp;&amp; laNode-&gt;score == curNode-&gt;score )
<a name="l00757"></a>00757                 {
<a name="l00758"></a>00758                         ++runLen;
<a name="l00759"></a>00759                         ++laNode;
<a name="l00760"></a>00760                 }
<a name="l00761"></a>00761 
<a name="l00763"></a>00763                 *dst++ = runLen;
<a name="l00764"></a>00764                 *dst++ = ( <span class="keywordtype">unsigned</span> char )curNode-&gt;score;
<a name="l00765"></a>00765         }
<a name="l00766"></a>00766 <span class="preprocessor">#else</span>
<a name="l00767"></a>00767 <span class="preprocessor"></span><span class="preprocessor">#error implement me!</span>
<a name="l00768"></a>00768 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00770"></a>00770 <span class="preprocessor">        if ( ( size_t )dst &amp; 2 )</span>
<a name="l00771"></a>00771 <span class="preprocessor"></span>        {
<a name="l00772"></a>00772                 *dst++ = 0;
<a name="l00773"></a>00773                 *dst++ = 0;
<a name="l00774"></a>00774         }
<a name="l00775"></a>00775 
<a name="l00777"></a>00777         <a class="code" href="common__afx_8h.html#9f04579206286b6dc8c9708063450144" title="memory functions.">MemSet</a>( dst, 0, srcSize );
<a name="l00778"></a>00778         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dstBit = 0;
<a name="l00779"></a>00779 
<a name="l00781"></a>00781         src = ( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* )srcData;
<a name="l00782"></a>00782         <span class="keywordflow">while</span> ( src != end )
<a name="l00783"></a>00783         {
<a name="l00786"></a>00786                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> curBits = 0;
<a name="l00787"></a>00787                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count = 0;
<a name="l00788"></a>00788                 STreeNode* node = nodeData + *src++;
<a name="l00789"></a>00789                 <span class="keywordflow">while</span> ( node != root )
<a name="l00790"></a>00790                 {
<a name="l00792"></a>00792                         curBits &lt;&lt;= 1;
<a name="l00793"></a>00793                         curBits |= ( ( node == node-&gt;parent-&gt;children[ 1 ] ) != 0 );
<a name="l00794"></a>00794                         node = node-&gt;parent;
<a name="l00795"></a>00795                         ++count;
<a name="l00796"></a>00796                 }
<a name="l00797"></a>00797 
<a name="l00799"></a>00799                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> curSel = 1;
<a name="l00800"></a>00800                 <span class="keywordflow">while</span> ( count-- &gt; 0 )
<a name="l00801"></a>00801                 {
<a name="l00803"></a>00803                         dst[ dstBit &gt;&gt; 3 ] |= ( ( curBits &amp; curSel ) != 0 ) &lt;&lt; ( dstBit &amp; 7 );
<a name="l00804"></a>00804                         curSel += curSel;
<a name="l00805"></a>00805                         dstBit += 1;
<a name="l00806"></a>00806                 }
<a name="l00807"></a>00807         }
<a name="l00808"></a>00808 
<a name="l00810"></a>00810         _bitCount = dstBit;
<a name="l00811"></a>00811 }
<a name="l00812"></a>00812 
<a name="l00813"></a>00813 <span class="comment">//----------------------------------------------------------</span>
<a name="l00814"></a>00814 <span class="keywordtype">void</span>
<a name="l00815"></a>00815 UHuffman::SetEncodedBits( <span class="keyword">const</span> <span class="keywordtype">void</span>* src, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bitCount )
<a name="l00816"></a>00816 {
<a name="l00818"></a>00818         <span class="keywordflow">if</span> ( _ownBits )
<a name="l00819"></a>00819                 <span class="keyword">delete</span>[] _bitStream;
<a name="l00820"></a>00820 
<a name="l00822"></a>00822         _bitStream = ( <span class="keywordtype">void</span>* )src;
<a name="l00823"></a>00823         _bitCount = bitCount;
<a name="l00824"></a>00824         _ownBits = <span class="keyword">false</span>;
<a name="l00825"></a>00825 }
<a name="l00826"></a>00826 
<a name="l00827"></a>00827 <span class="comment">//----------------------------------------------------------</span>
<a name="l00828"></a>00828 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00829"></a>00829 UHuffman::Decode( <span class="keywordtype">void</span>* dstData )<span class="keyword"> const</span>
<a name="l00830"></a>00830 <span class="keyword"></span>{
<a name="l00832"></a>00832         STreeNode nodeData[ 513 ];
<a name="l00833"></a>00833         STreeNode* nodes[ 513 ];
<a name="l00834"></a>00834         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 513; ++i )
<a name="l00835"></a>00835         {
<a name="l00836"></a>00836                 nodeData[ i ].value = i;
<a name="l00837"></a>00837                 nodeData[ i ].score = 0;
<a name="l00838"></a>00838                 nodeData[ i ].children[ 0 ] = 0;
<a name="l00839"></a>00839                 nodeData[ i ].children[ 1 ] = 0;
<a name="l00840"></a>00840                 nodeData[ i ].parent = 0;
<a name="l00841"></a>00841                 nodes[ i ] = nodeData + i;
<a name="l00842"></a>00842         }
<a name="l00843"></a>00843 
<a name="l00845"></a>00845         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="glext_8h.html#57f14e05b1900f16a2da82ade47d0c6d">index</a> = 0;
<a name="l00846"></a>00846         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* src = ( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* )_bitStream;
<a name="l00847"></a>00847         <span class="keywordflow">while</span> ( index &lt; 256 )
<a name="l00848"></a>00848         {
<a name="l00850"></a>00850                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> runLen = *src++;
<a name="l00851"></a>00851                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> score = *src++;
<a name="l00852"></a>00852                 <span class="keywordflow">while</span> ( runLen-- &gt; 0 )
<a name="l00853"></a>00853                         nodeData[ index++ ].score = score;
<a name="l00854"></a>00854         }
<a name="l00855"></a>00855 
<a name="l00857"></a>00857         <span class="keywordflow">if</span> ( ( <span class="keywordtype">size_t</span> )src &amp; 2 )
<a name="l00858"></a>00858                 src += 2;
<a name="l00859"></a>00859 
<a name="l00861"></a>00861         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> minDepth = 0;
<a name="l00862"></a>00862         STreeNode* root = BuildTree( nodes, &amp;minDepth );
<a name="l00863"></a>00863 
<a name="l00865"></a>00865         minDepth = <a class="code" href="common__afx_8h.html#0296e17691267defafdfde06589f50d5">Min</a>( minDepth, 8U );
<a name="l00866"></a>00866         STreeNode* minHash[ 256 ];
<a name="l00867"></a>00867 
<a name="l00869"></a>00869         STreeNode* node = root;
<a name="l00870"></a>00870         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bit = 1;
<a name="l00871"></a>00871         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> minCount = 1 &lt;&lt; minDepth;
<a name="l00872"></a>00872         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> minMask = minCount - 1;
<a name="l00873"></a>00873         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; minCount; ++i )
<a name="l00874"></a>00874         {
<a name="l00875"></a>00875                 node = root;
<a name="l00876"></a>00876                 bit = 1;
<a name="l00877"></a>00877                 <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; minDepth; ++j )
<a name="l00878"></a>00878                 {
<a name="l00879"></a>00879                         node = node-&gt;children[ ( i &amp; bit ) != 0 ];
<a name="l00880"></a>00880                         bit += bit;
<a name="l00881"></a>00881                 }
<a name="l00882"></a>00882 
<a name="l00884"></a>00884                 minHash[ i ] = node;
<a name="l00885"></a>00885         }
<a name="l00886"></a>00886 
<a name="l00888"></a>00888         node = root;
<a name="l00889"></a>00889         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> curBit = 0;
<a name="l00890"></a>00890         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* srcDwords = ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* )src;
<a name="l00891"></a>00891         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* dst = ( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* )dstData;
<a name="l00892"></a>00892 <span class="preprocessor">#if 1</span>
<a name="l00893"></a>00893 <span class="preprocessor"></span>        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k8 = 8;
<a name="l00894"></a>00894         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k12 = 12;
<a name="l00895"></a>00895         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bitCount = _bitCount;
<a name="l00896"></a>00896         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> result = 0;
<a name="l00897"></a>00897         __asm
<a name="l00898"></a>00898         {
<a name="l00899"></a>00899                 ; ecx = current bit.
<a name="l00900"></a>00900                 ; eax = current dword.
<a name="l00901"></a>00901                 ; ebx = current dword bit.
<a name="l00902"></a>00902                 xor             ecx, ecx
<a name="l00903"></a>00903                 mov             esi, srcDwords
<a name="l00904"></a>00904                 mov             edi, dst
<a name="l00905"></a>00905 
<a name="l00906"></a>00906         $loop:
<a name="l00907"></a>00907                 mov             eax, ecx                                                ; calculate the <a class="code" href="glext_8h.html#fdd0f0e67e302eefcb4f6b23732e7ea3">source</a> dwords and bit <a class="code" href="_g_l_8h.html#0c1a6a349ce1520ca0284e13dcad1f86">indices</a>.
<a name="l00908"></a>00908                 mov             ebx, ecx
<a name="l00909"></a>00909                 shr             eax, 3
<a name="l00910"></a>00910                 and             eax, ~3;
<a name="l00911"></a>00911                 and             ebx, 31
<a name="l00912"></a>00912                 <span class="keyword">add</span>             ecx, minDepth                                   ; advance the <a class="code" href="glext_8h.html#fdd0f0e67e302eefcb4f6b23732e7ea3">source</a> <a class="code" href="glext_8h.html#47cf4c5c5dc1c252e3be3e4f59ffb98a">bits</a>
<a name="l00913"></a>00913 
<a name="l00914"></a>00914                 movd    mm1, [ esi + eax + 4 ]
<a name="l00915"></a>00915                 movd    mm0, [ esi + eax ]                              ; load <a class="code" href="glext_8h.html#83ad0ee7f1e06b59c90271716e689080">in</a> two dwords and pack them together.
<a name="l00916"></a>00916                 psllq   mm1, 32
<a name="l00917"></a>00917                 por             mm0, mm1
<a name="l00918"></a>00918 
<a name="l00919"></a>00919                 movd    mm2, ebx                                                ; <span class="keyword">get</span> the <a class="code" href="glext_8h.html#47cf4c5c5dc1c252e3be3e4f59ffb98a">bits</a> we need to process now.
<a name="l00920"></a>00920                 psrlq   mm0, mm2
<a name="l00921"></a>00921                 movq    mm1, mm0
<a name="l00922"></a>00922 
<a name="l00923"></a>00923                 movd    eax, mm1                                                ; perform the <a class="code" href="_u_t_x_8cpp.html#3f06f0e9f7beb8214afeea0b18ef8377">min</a>-hash lookup.
<a name="l00924"></a>00924                 and             eax, minMask
<a name="l00925"></a>00925                 mov             edx, [ minHash + 4 * eax ]
<a name="l00926"></a>00926 
<a name="l00927"></a>00927                 mov             ebx, [ edx ]                                    ; check the <a class="code" href="glext_8h.html#6a4f8a1a444e9080b297963b3db29fe0">value</a> to see <span class="keywordflow">if</span> the node is <a class="code" href="glext_8h.html#3309789fc188587d666cda5ece79cf82">a</a> leaf.
<a name="l00928"></a>00928                 cmp             bx, 256
<a name="l00929"></a>00929                 jge             $walk
<a name="l00930"></a>00930 
<a name="l00931"></a>00931                 mov             BYTE PTR [ edi ], bl                    ; write the current <a class="code" href="glext_8h.html#6a4f8a1a444e9080b297963b3db29fe0">value</a>.
<a name="l00932"></a>00932                 <span class="keyword">add</span>             edi, 1
<a name="l00933"></a>00933 
<a name="l00934"></a>00934                 cmp             ecx, bitCount                                   ; determine whether or not to loop.
<a name="l00935"></a>00935                 jl              $loop
<a name="l00936"></a>00936 
<a name="l00937"></a>00937         $walk:
<a name="l00938"></a>00938                 ; we need to walk the tree.
<a name="l00939"></a>00939                 mov             ebx, minCount                                   ; <span class="keyword">set</span> ebx to minCount.
<a name="l00940"></a>00940 
<a name="l00941"></a>00941         $walk_loop:
<a name="l00942"></a>00942                 movd    eax, mm0                        ; THIS IS EXPENSIVE AND IS CAUSING PROBLEMS.
<a name="l00943"></a>00943 
<a name="l00944"></a>00944 #<span class="keywordflow">if</span> 1
<a name="l00945"></a>00945                 <a class="code" href="_u_table_8cpp.html#365a25be86cf4391400fe0d9e4d6f000" title="class header.">test</a>    eax, ebx                                                ; place either the <a class="code" href="glext_8h.html#85b8f6c07fbc1fb5d77c2ae090f21995">left</a> node or the <a class="code" href="glext_8h.html#5ffadbbacc6b89cf6218bc43b384d3fe">right</a> node into
<a name="l00946"></a>00946 
<a name="l00947"></a>00947                 ; <span class="keyword">this</span> runs better on non-uniform <a class="code" href="_g_l_8h.html#89ce72163394e6aef63b551a8806e93f">data</a> sets (which is what
<a name="l00948"></a>00948                 ; huffman coding is best suited to deal with)
<a name="l00949"></a>00949                 setnz   al
<a name="l00950"></a>00950                 and             eax, 0x000000FF
<a name="l00951"></a>00951                 <span class="keyword">add</span>             eax, eax
<a name="l00952"></a>00952                 <span class="keyword">add</span>             eax, eax
<a name="l00953"></a>00953                 mov             edx, [ edx + eax + 8 ]                  ; edx <span class="keywordflow">for</span> traversal.
<a name="l00954"></a>00954 #<span class="keywordflow">else</span>
<a name="l00955"></a>00955                 cmovz   edx, [ edx + 8  ]
<a name="l00956"></a>00956                 cmovnz  edx, [ edx + 12 ]
<a name="l00957"></a>00957 <span class="preprocessor">#endif</span>
<a name="l00958"></a>00958 <span class="preprocessor"></span>
<a name="l00959"></a>00959                 <span class="keyword">add</span>             ebx, ebx                                                ; multiply ebx <a class="code" href="glext_8h.html#ee54e9aab2837a54be2ff5fb1c073bd2">by</a> two to <span class="keyword">get</span> the next bit.
<a name="l00960"></a>00960                 mov             eax, [ edx ]
<a name="l00961"></a>00961                 <span class="keyword">add</span>             ecx, 1                                                  ; increment the bit counter.
<a name="l00962"></a>00962                 cmp             ax, 256
<a name="l00963"></a>00963                 jge             $walk_loop
<a name="l00964"></a>00964 
<a name="l00965"></a>00965                 mov             BYTE PTR [ edi ], al                    ; write the current <a class="code" href="glext_8h.html#6a4f8a1a444e9080b297963b3db29fe0">value</a>.
<a name="l00966"></a>00966                 <span class="keyword">add</span>             edi, 1
<a name="l00967"></a>00967 
<a name="l00968"></a>00968                 cmp             ecx, bitCount                                   ; determine whether or not to loop.
<a name="l00969"></a>00969                 jl              $loop
<a name="l00970"></a>00970 
<a name="l00971"></a>00971                 ; all done!
<a name="l00972"></a>00972                 emms
<a name="l00973"></a>00973 
<a name="l00974"></a>00974                 sub             edi, dst                                                ; <span class="keywordflow">return</span> the number of bytes written.
<a name="l00975"></a>00975                 mov             result, edi
<a name="l00976"></a>00976         }
<a name="l00977"></a>00977 
<a name="l00978"></a>00978         <span class="keywordflow">return</span> result;
<a name="l00979"></a>00979 <span class="preprocessor">#else</span>
<a name="l00980"></a>00980 <span class="preprocessor"></span>        <span class="keywordflow">while</span> ( curBit &lt; _bitCount )
<a name="l00981"></a>00981         {
<a name="l00983"></a>00983                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bitIdx = curBit &amp; 31;
<a name="l00984"></a>00984                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dwordIdx = curBit &gt;&gt; 5;
<a name="l00985"></a>00985 
<a name="l00987"></a>00987                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="glext_8h.html#47cf4c5c5dc1c252e3be3e4f59ffb98a">bits</a> = srcDwords[ dwordIdx ];
<a name="l00988"></a>00988                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bitsNext = srcDwords[ dwordIdx + 1 ];
<a name="l00989"></a>00989                 <a class="code" href="_u_t_x_8h.html#a254d9bac3ece6a9d99def539e8a80eb">__int64</a> totalBits = bitsNext;
<a name="l00990"></a>00990                 totalBits &lt;&lt;= 32;
<a name="l00991"></a>00991                 totalBits |= bits;
<a name="l00992"></a>00992                 totalBits &gt;&gt;= bitIdx;
<a name="l00993"></a>00993                 bits = ( <span class="keywordtype">unsigned</span> <a class="code" href="_g_l_aux_8h.html#b832c174e145540d491b0830fc05dbb1">int</a> )( totalBits &amp; 0xFFFFFFFF );
<a name="l00994"></a>00994 <span class="comment">/*</span>
<a name="l00996"></a>00996 <span class="comment">                __asm</span>
<a name="l00997"></a>00997 <span class="comment">                {</span>
<a name="l00998"></a>00998 <span class="comment">                        mov             eax, bits</span>
<a name="l00999"></a>00999 <span class="comment">                        mov             ebx, bitsNext</span>
<a name="l01000"></a>01000 <span class="comment">                        mov             cl, byte ptr bitIdx</span>
<a name="l01001"></a>01001 <span class="comment">                        shrd    eax, ebx, cl</span>
<a name="l01002"></a>01002 <span class="comment">                        mov             bits, eax</span>
<a name="l01003"></a>01003 <span class="comment">                }</span>
<a name="l01004"></a>01004 <span class="comment">*/</span>
<a name="l01007"></a>01007                 node = minHash[ bits &amp; minMask ];
<a name="l01008"></a>01008                 curBit += minDepth;
<a name="l01009"></a>01009 
<a name="l01011"></a>01011                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bitPos = minCount;
<a name="l01012"></a>01012                 <span class="keywordflow">while</span> ( node-&gt;value &gt;= 256 )
<a name="l01013"></a>01013                 {
<a name="l01014"></a>01014                         node = node-&gt;children[ ( bits &amp; bitPos ) != 0 ];
<a name="l01015"></a>01015                         bitPos += bitPos;
<a name="l01016"></a>01016                         ++curBit;
<a name="l01017"></a>01017                 }
<a name="l01018"></a>01018 
<a name="l01020"></a>01020                 *dst++ = ( <span class="keywordtype">unsigned</span> char )node-&gt;value;
<a name="l01021"></a>01021         }
<a name="l01022"></a>01022 
<a name="l01024"></a>01024         <span class="keywordflow">return</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> )( dst - ( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* )dstData );
<a name="l01025"></a>01025 <span class="preprocessor">#endif</span>
<a name="l01026"></a>01026 <span class="preprocessor"></span>}
<a name="l01027"></a>01027 
<a name="l01028"></a>01028 <span class="comment">//----------------------------------------------------------</span>
<a name="l01029"></a>01029 <span class="keywordtype">void</span>
<a name="l01030"></a>01030 UHuffman::EncodeFast( <span class="keyword">const</span> <span class="keywordtype">void</span>* srcData, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> srcSize )
<a name="l01031"></a>01031 {
<a name="l01033"></a>01033         STreeNode nodeData[ 513 ];
<a name="l01034"></a>01034         STreeNode* nodes[ 513 ];
<a name="l01035"></a>01035         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 513; ++i )
<a name="l01036"></a>01036         {
<a name="l01037"></a>01037                 nodeData[ i ].value = i;
<a name="l01038"></a>01038                 nodeData[ i ].score = 0;
<a name="l01039"></a>01039                 nodeData[ i ].children[ 0 ] = 0;
<a name="l01040"></a>01040                 nodeData[ i ].children[ 1 ] = 0;
<a name="l01041"></a>01041                 nodeData[ i ].parent = 0;
<a name="l01042"></a>01042                 nodes[ i ] = nodeData + i;
<a name="l01043"></a>01043         }
<a name="l01044"></a>01044 
<a name="l01047"></a>01047         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* src = ( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* )srcData;
<a name="l01048"></a>01048         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* end = src + srcSize;
<a name="l01049"></a>01049         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxScore = 0;
<a name="l01050"></a>01050         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> scores[ 256 ];
<a name="l01051"></a>01051         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sum = 0;
<a name="l01052"></a>01052         <a class="code" href="common__afx_8h.html#9f04579206286b6dc8c9708063450144" title="memory functions.">MemSet</a>( scores, 0, <span class="keyword">sizeof</span>( scores ) );
<a name="l01053"></a>01053         <span class="keywordflow">while</span> ( src != end )
<a name="l01054"></a>01054         {
<a name="l01056"></a>01056                 scores[ *src ] += 1;
<a name="l01057"></a>01057                 maxScore = <a class="code" href="common__afx_8h.html#dd09d155ffe827b203d3236b451752e7">Max</a>( scores[ *src++ ], maxScore );
<a name="l01058"></a>01058         }
<a name="l01059"></a>01059 
<a name="l01061"></a>01061         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> adjust = 0;
<a name="l01062"></a>01062         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxCount = <a class="code" href="common__afx_8h.html#df309c61a344cf812c926af221641f24">Log2</a>( maxScore ) + 1;
<a name="l01063"></a>01063         <span class="keywordflow">if</span> ( maxCount &gt; SCORE_BIT_COUNT )
<a name="l01064"></a>01064                 adjust = maxCount - SCORE_BIT_COUNT;
<a name="l01065"></a>01065 
<a name="l01067"></a>01067         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mask = ( 1 &lt;&lt; adjust ) - 1;
<a name="l01068"></a>01068         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 256; ++i )
<a name="l01069"></a>01069         {
<a name="l01070"></a>01070                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> roundUp = ( scores[ i ] &amp; mask ) != 0;
<a name="l01071"></a>01071                 scores[ i ] &gt;&gt;= adjust;
<a name="l01072"></a>01072                 scores[ i ] += roundUp;
<a name="l01073"></a>01073                 nodeData[ i ].score = ( <span class="keywordtype">unsigned</span> short )scores[ i ];
<a name="l01074"></a>01074         }
<a name="l01075"></a>01075 
<a name="l01077"></a>01077         STreeNode* root = BuildTree( nodes );
<a name="l01078"></a>01078 
<a name="l01081"></a>01081         _bitStream = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[ srcSize + 513 + 4 ];
<a name="l01082"></a>01082         _ownBits = <span class="keyword">true</span>;
<a name="l01083"></a>01083 
<a name="l01085"></a>01085         <a class="code" href="class_u_bit_writer.html" title="Purpose: To efficiently write a stream of bits.">UBitWriter</a> writer( ( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* )_bitStream );
<a name="l01086"></a>01086 
<a name="l01088"></a>01088         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bitCounts[ 256 ];
<a name="l01089"></a>01089         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> symbols[ 256 ];
<a name="l01090"></a>01090         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> rareSymbols[ 256 ];       
<a name="l01091"></a>01091 <span class="comment">//      unsigned char bitLenOffsets[ 17 ];      //! offsets into the rare symbol table for group starts.</span>
<a name="l01092"></a>01092 <span class="comment">//      unsigned int minCodes[ 17 ];            //! note that we only need 9..16.</span>
<a name="l01093"></a>01093 
<a name="l01095"></a>01095         SRareSymbol rareSymbolInfo[ 256 ];
<a name="l01096"></a>01096         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rareSymbolCount = 0;
<a name="l01097"></a>01097 
<a name="l01100"></a>01100 <span class="comment">//      memset( minCodes, 0xFF, sizeof( minCodes ) );</span>
<a name="l01101"></a>01101 <span class="comment">//      memset( bitLenOffsets, 0, sizeof( bitLenOffsets ) );</span>
<a name="l01102"></a>01102         memset( symbols, 0, <span class="keyword">sizeof</span>( symbols ) );
<a name="l01103"></a>01103         memset( rareSymbols, 0, <span class="keyword">sizeof</span>( rareSymbols ) );
<a name="l01104"></a>01104         memset( bitCounts, 0, <span class="keyword">sizeof</span>( bitCounts ) );
<a name="l01105"></a>01105 
<a name="l01107"></a>01107         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bitCount = 0;
<a name="l01108"></a>01108         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> shift = 0;
<a name="l01109"></a>01109         STreeNode* child = 0;
<a name="l01110"></a>01110         STreeNode* curNode = 0;
<a name="l01111"></a>01111 
<a name="l01113"></a>01113         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 256; ++i )
<a name="l01114"></a>01114         {
<a name="l01116"></a>01116                 STreeNode* node = nodeData + i;
<a name="l01117"></a>01117                 <span class="keywordflow">if</span> ( node-&gt;parent == 0 )
<a name="l01118"></a>01118                         <span class="keywordflow">continue</span>;
<a name="l01119"></a>01119 
<a name="l01122"></a>01122                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bitCode = 0;
<a name="l01123"></a>01123                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bitCount = 0;
<a name="l01124"></a>01124                 <span class="keywordflow">do</span>
<a name="l01125"></a>01125                 {
<a name="l01127"></a>01127                         bitCode &lt;&lt;= 1;
<a name="l01128"></a>01128                         bitCode |= ( node == node-&gt;parent-&gt;children[ 1 ] );
<a name="l01129"></a>01129 
<a name="l01131"></a>01131                         ++bitCount;
<a name="l01132"></a>01132 
<a name="l01134"></a>01134                         node = node-&gt;parent;
<a name="l01135"></a>01135                 }
<a name="l01136"></a>01136                 <span class="keywordflow">while</span> ( node != root );
<a name="l01137"></a>01137 
<a name="l01139"></a>01139                 <span class="keywordflow">if</span> ( bitCount &lt;= 8 )
<a name="l01140"></a>01140                 {
<a name="l01143"></a>01143                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bitsLeft = ( 8 - bitCount );
<a name="l01144"></a>01144                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> entryCount = 1 &lt;&lt; bitsLeft;
<a name="l01145"></a>01145                         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; entryCount; ++j )
<a name="l01146"></a>01146                         {
<a name="l01148"></a>01148                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tableIndex = ( j &lt;&lt; bitCount ) | bitCode;
<a name="l01149"></a>01149                                 symbols[ tableIndex ] = ( <span class="keywordtype">unsigned</span> char )i;
<a name="l01150"></a>01150 
<a name="l01152"></a>01152                                 bitCounts[ tableIndex ] = bitCount - 1;
<a name="l01153"></a>01153                         }
<a name="l01154"></a>01154                 }
<a name="l01155"></a>01155                 <span class="keywordflow">else</span>
<a name="l01156"></a>01156                 {
<a name="l01158"></a>01158                         SRareSymbol* symbol = rareSymbolInfo + rareSymbolCount++;
<a name="l01159"></a>01159 
<a name="l01161"></a>01161                         symbol-&gt;symbol = i;
<a name="l01162"></a>01162                         symbol-&gt;code = bitCode;
<a name="l01163"></a>01163                         symbol-&gt;codeLen = bitCount;
<a name="l01164"></a>01164 
<a name="l01167"></a>01167                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tableIndex = bitCode &amp; 0xFF;
<a name="l01168"></a>01168                         bitCounts[ tableIndex ] = <a class="code" href="common__afx_8h.html#dd09d155ffe827b203d3236b451752e7">Max</a>( bitCounts[ tableIndex ], ( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> )( bitCount - 1 ) );
<a name="l01169"></a>01169                 }
<a name="l01170"></a>01170         }
<a name="l01171"></a>01171 
<a name="l01173"></a>01173         std::sort( rareSymbolInfo, rareSymbolInfo + rareSymbolCount, RareSymbolSort );
<a name="l01174"></a>01174 
<a name="l01177"></a>01177         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> groupSize = 0;
<a name="l01178"></a>01178         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="glext_8h.html#a782f3aea23e3c30029c811241dc2c82">offset</a> = 0;
<a name="l01179"></a>01179         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; rareSymbolCount; ++i )
<a name="l01180"></a>01180         {
<a name="l01182"></a>01182                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lowBits = rareSymbolInfo[ i ].code &amp; 0xFF;
<a name="l01183"></a>01183 
<a name="l01186"></a>01186                 symbols[ lowBits ] = offset;
<a name="l01187"></a>01187 
<a name="l01189"></a>01189                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxBitCount = bitCounts[ lowBits ] - 7;
<a name="l01190"></a>01190                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> regionSize = 1 &lt;&lt; maxBitCount;
<a name="l01191"></a>01191 
<a name="l01193"></a>01193                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> la = i + 1;
<a name="l01194"></a>01194                 <span class="keywordflow">while</span> ( ( rareSymbolInfo[ la ].code &amp; 0xFF ) == lowBits )
<a name="l01195"></a>01195                         ++la;
<a name="l01196"></a>01196 
<a name="l01198"></a>01198                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> highBits = lowBits &gt;&gt; 8;
<a name="l01199"></a>01199                 <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = i + 1; j &lt;= la; ++j )
<a name="l01200"></a>01200                 {
<a name="l01201"></a>01201                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> code = j - offset;
<a name="l01202"></a>01202                         <span class="keywordflow">if</span> ( ( code &amp; highBits ) == highBits )
<a name="l01203"></a>01203                                 rareSymbols[ offset + j ] = rareSymbolInfo[ j ].symbol;
<a name="l01204"></a>01204                 }
<a name="l01205"></a>01205 
<a name="l01207"></a>01207                 offset += regionSize;
<a name="l01208"></a>01208 <span class="comment">/*</span>
<a name="l01210"></a>01210 <span class="comment">                unsigned int la = i + 1;</span>
<a name="l01211"></a>01211 <span class="comment">                while ( ( rareSymbolInfo[ la ].code &amp; 0xFF ) == lowBits )</span>
<a name="l01212"></a>01212 <span class="comment">                        ++la;</span>
<a name="l01213"></a>01213 <span class="comment"></span>
<a name="l01215"></a>01215 <span class="comment">                for ( unsigned int j = i; j &lt; la; ++j )</span>
<a name="l01216"></a>01216 <span class="comment">                        rareSymbols[ offset + ( rareSymbolInfo[ j ].code &gt;&gt; 8 ) ] = rareSymbolInfo[ j ].symbol;</span>
<a name="l01217"></a>01217 <span class="comment"></span>
<a name="l01219"></a>01219 <span class="comment">                unsigned int maxValue = ( rareSymbolInfo[ la - 1 ].code &gt;&gt; 8 );</span>
<a name="l01220"></a>01220 <span class="comment"></span>
<a name="l01222"></a>01222 <span class="comment">                offset += maxValue + 1;</span>
<a name="l01223"></a>01223 <span class="comment">*/</span>
<a name="l01224"></a>01224         }
<a name="l01225"></a>01225 
<a name="l01228"></a>01228         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 256; ++i )
<a name="l01229"></a>01229                 writer.WriteBits( bitCounts[ i ], 4 );
<a name="l01230"></a>01230 
<a name="l01232"></a>01232         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 256; ++i )
<a name="l01233"></a>01233                 writer.WriteBits( symbols[ i ], 8 );
<a name="l01234"></a>01234 
<a name="l01236"></a>01236         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 256; ++i )
<a name="l01237"></a>01237                 writer.WriteBits( rareSymbols[ i ], 8 );
<a name="l01238"></a>01238 <span class="comment">/*</span>
<a name="l01240"></a>01240 <span class="comment">        for ( unsigned int i = 9; i &lt; 17; ++i )</span>
<a name="l01241"></a>01241 <span class="comment">                writer.WriteBits( minCodes[ i ], i );</span>
<a name="l01242"></a>01242 <span class="comment"></span>
<a name="l01244"></a>01244 <span class="comment">        for ( unsigned int i = 9; i &lt; 17; ++i )</span>
<a name="l01245"></a>01245 <span class="comment">                writer.WriteBits( bitLenOffsets[ i ], 8 );</span>
<a name="l01246"></a>01246 <span class="comment">*/</span>
<a name="l01248"></a>01248         src = ( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* )srcData;
<a name="l01249"></a>01249         <span class="keywordflow">while</span> ( src != end )
<a name="l01250"></a>01250         {
<a name="l01253"></a>01253                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bits = 0;
<a name="l01254"></a>01254                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bitCount = 0;
<a name="l01255"></a>01255                 STreeNode* node = nodeData + *src++;
<a name="l01256"></a>01256                 <span class="keywordflow">while</span> ( node != root )
<a name="l01257"></a>01257                 {
<a name="l01259"></a>01259                         bits &lt;&lt;= 1;
<a name="l01260"></a>01260                         bits |= ( node == node-&gt;parent-&gt;children[ 1 ] );
<a name="l01261"></a>01261 
<a name="l01263"></a>01263                         ++bitCount;
<a name="l01264"></a>01264 
<a name="l01266"></a>01266                         node = node-&gt;parent;
<a name="l01267"></a>01267                 }
<a name="l01268"></a>01268 
<a name="l01270"></a>01270                 writer.WriteBits( bits, bitCount );
<a name="l01271"></a>01271         }
<a name="l01272"></a>01272 
<a name="l01274"></a>01274         writer.Finish();
<a name="l01275"></a>01275 
<a name="l01277"></a>01277         _bitCount = writer.GetBitCount();
<a name="l01278"></a>01278 }
<a name="l01279"></a>01279 
<a name="l01280"></a>01280 <span class="comment">//----------------------------------------------------------</span>
<a name="l01281"></a>01281 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l01282"></a>01282 UHuffman::DecodeFast( <span class="keywordtype">void</span>* dest )
<a name="l01283"></a>01283 {
<a name="l01284"></a>01284         <a class="code" href="class_u_bit_reader.html" title="Purpose: To efficiently read a stream of bits.">UBitReader</a> reader( ( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* )_bitStream, ( _bitCount + 7 ) / 8 );
<a name="l01285"></a>01285 
<a name="l01287"></a>01287         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bitCounts[ 256 ];
<a name="l01288"></a>01288         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> symbols[ 256 ];
<a name="l01289"></a>01289         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> rareSymbols[ 256 ];
<a name="l01290"></a>01290         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> minCodesTest[ 17 ];
<a name="l01291"></a>01291         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> minCodes[ 17 ];
<a name="l01292"></a>01292         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bitLenOffsets[ 17 ];
<a name="l01293"></a>01293 
<a name="l01294"></a>01294         <a class="code" href="common__afx_8h.html#9f04579206286b6dc8c9708063450144" title="memory functions.">MemSet</a>( minCodes, 0, <span class="keyword">sizeof</span>( minCodes ) );
<a name="l01295"></a>01295         <a class="code" href="common__afx_8h.html#9f04579206286b6dc8c9708063450144" title="memory functions.">MemSet</a>( minCodesTest, 0, <span class="keyword">sizeof</span>( minCodesTest ) );
<a name="l01296"></a>01296         <a class="code" href="common__afx_8h.html#9f04579206286b6dc8c9708063450144" title="memory functions.">MemSet</a>( bitLenOffsets, 0, <span class="keyword">sizeof</span>( bitLenOffsets ) );
<a name="l01297"></a>01297 
<a name="l01299"></a>01299         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 256; ++i )
<a name="l01300"></a>01300                 bitCounts[ i ] = reader.ReadBits( 4 );
<a name="l01301"></a>01301 
<a name="l01303"></a>01303         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 256; ++i )
<a name="l01304"></a>01304                 symbols[ i ] = reader.ReadBits( 8 );
<a name="l01305"></a>01305 
<a name="l01307"></a>01307         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 256; ++i )
<a name="l01308"></a>01308                 rareSymbols[ i ] = reader.ReadBits( 8 );
<a name="l01309"></a>01309 <span class="comment">/*</span>
<a name="l01311"></a>01311 <span class="comment">        for ( unsigned int i = 9; i &lt; 17; ++i )</span>
<a name="l01312"></a>01312 <span class="comment">        {</span>
<a name="l01313"></a>01313 <span class="comment">                minCodes[ i ] = reader.ReadBits( i );</span>
<a name="l01314"></a>01314 <span class="comment">                minCodesTest[ i ] = ( 1 &lt;&lt; i ) | minCodes[ i ]; //! left justify.</span>
<a name="l01315"></a>01315 <span class="comment">        }</span>
<a name="l01316"></a>01316 <span class="comment"></span>
<a name="l01318"></a>01318 <span class="comment">        for ( unsigned int i = 9; i &lt; 17; ++i )</span>
<a name="l01319"></a>01319 <span class="comment">                bitLenOffsets[ i ] = reader.ReadBits( 8 );</span>
<a name="l01320"></a>01320 <span class="comment">*/</span>
<a name="l01322"></a>01322         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* output = ( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* )dest;
<a name="l01323"></a>01323         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index = 0;
<a name="l01324"></a>01324         <span class="keywordtype">int</span> bitsRemaining = reader.GetBitsRemaining();
<a name="l01325"></a>01325         <span class="keywordflow">while</span> ( bitsRemaining &gt; 0 )
<a name="l01326"></a>01326         {
<a name="l01328"></a>01328                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="glext_8h.html#6a4f8a1a444e9080b297963b3db29fe0">value</a> = reader.PeekBits( 8 );
<a name="l01329"></a>01329                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bitCount = bitCounts[ value ] + 1;
<a name="l01330"></a>01330                 <span class="keywordflow">if</span> ( bitCount &lt;= 8 )
<a name="l01331"></a>01331                 {
<a name="l01333"></a>01333                         output[ index++ ] = symbols[ value ];
<a name="l01334"></a>01334                         reader.SkipBits( bitCount );
<a name="l01335"></a>01335                         bitsRemaining -= bitCount;
<a name="l01336"></a>01336                 }
<a name="l01337"></a>01337                 <span class="keywordflow">else</span>
<a name="l01338"></a>01338                 {
<a name="l01340"></a>01340                         value = reader.PeekBits( 16 );
<a name="l01341"></a>01341 
<a name="l01343"></a>01343                         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> rareSymbolOffset = symbols[ value &amp; 0xFF ];
<a name="l01344"></a>01344 
<a name="l01346"></a>01346                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mask = ( 1 &lt;&lt; bitCount ) - 1;
<a name="l01347"></a>01347                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> code = ( value &amp; mask ) &gt;&gt; 8;
<a name="l01348"></a>01348 
<a name="l01353"></a>01353                         output[ index++ ] = rareSymbols[ rareSymbolOffset + code ];
<a name="l01354"></a>01354 
<a name="l01356"></a>01356 <span class="comment">//                      reader.SkipBits( bitsUsed );</span>
<a name="l01357"></a>01357                 }
<a name="l01358"></a>01358         }
<a name="l01359"></a>01359 
<a name="l01361"></a>01361         <span class="keywordflow">return</span> index;
<a name="l01362"></a>01362 }
<a name="l01363"></a>01363 
<a name="l01364"></a>01364 
<a name="l01365"></a>01365 <span class="comment">//==========================================================</span>
<a name="l01367"></a>01367 <span class="comment"></span><span class="comment">//==========================================================</span>
<a name="l01368"></a>01368 
<a name="l01369"></a>01369 
<a name="l01370"></a>01370 <span class="comment">//**********************************************************</span>
<a name="l01372"></a>01372 <span class="comment"></span><span class="comment">//**********************************************************</span>
<a name="l01373"></a>01373 
<a name="l01374"></a>01374 <span class="comment">//----------------------------------------------------------</span>
<a name="l01375"></a>01375 STreeNode*
<a name="l01376"></a>01376 BuildTree( STreeNode** nodes, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* minDepth )
<a name="l01377"></a>01377 {
<a name="l01379"></a>01379         STreeNode** branches = nodes + 256;
<a name="l01380"></a>01380         STreeNode** leaves = nodes;
<a name="l01381"></a>01381 
<a name="l01383"></a>01383         STreeNode** curBranch = branches;
<a name="l01384"></a>01384 
<a name="l01386"></a>01386         STreeNode** dstLeaf = leaves;
<a name="l01387"></a>01387         STreeNode** curLeaf = leaves;
<a name="l01388"></a>01388         STreeNode** endLeaf = leaves + 256;
<a name="l01389"></a>01389         <span class="keywordflow">while</span> ( curLeaf != endLeaf )
<a name="l01390"></a>01390         {
<a name="l01391"></a>01391                 <span class="keywordflow">if</span> ( ( *curLeaf )-&gt;score != 0 )
<a name="l01392"></a>01392                         *dstLeaf++ = *curLeaf;
<a name="l01393"></a>01393                 ++curLeaf;
<a name="l01394"></a>01394         }
<a name="l01395"></a>01395 
<a name="l01397"></a>01397         <span class="keyword">typedef</span> std::multiset&lt; STreeNode*, ScoreSort &gt; PriorityQueue;
<a name="l01398"></a>01398         PriorityQueue nodeQueue;
<a name="l01399"></a>01399 
<a name="l01402"></a>01402         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nodeCount = ( <span class="keywordtype">unsigned</span> <a class="code" href="_g_l_aux_8h.html#b832c174e145540d491b0830fc05dbb1">int</a> )( dstLeaf - leaves );
<a name="l01403"></a>01403         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; nodeCount; ++i )
<a name="l01404"></a>01404                 nodeQueue.insert( leaves[ i ] );
<a name="l01405"></a>01405 
<a name="l01407"></a>01407         <span class="keywordflow">while</span> ( nodeQueue.size() &gt; 1 )
<a name="l01408"></a>01408         {
<a name="l01410"></a>01410                 STreeNode* child0 = *nodeQueue.begin();
<a name="l01411"></a>01411                 ( *curBranch )-&gt;children[ 0 ] = child0;
<a name="l01412"></a>01412                 ( *curBranch )-&gt;score = child0-&gt;score;
<a name="l01413"></a>01413                 child0-&gt;parent = ( *curBranch );
<a name="l01414"></a>01414                 nodeQueue.erase( nodeQueue.begin() );
<a name="l01415"></a>01415 
<a name="l01417"></a>01417                 <span class="keywordflow">if</span> ( nodeQueue.size() &gt; 0 )
<a name="l01418"></a>01418                 {
<a name="l01419"></a>01419                         STreeNode* child1 = *nodeQueue.begin();
<a name="l01420"></a>01420                         ( *curBranch )-&gt;children[ 1 ] = child1;
<a name="l01421"></a>01421                         ( *curBranch )-&gt;score += child1-&gt;score;
<a name="l01422"></a>01422                         child1-&gt;parent = ( *curBranch );
<a name="l01423"></a>01423                         nodeQueue.erase( nodeQueue.begin() );
<a name="l01424"></a>01424                 }
<a name="l01425"></a>01425 
<a name="l01427"></a>01427                 nodeQueue.insert( *curBranch++ );
<a name="l01428"></a>01428         }
<a name="l01429"></a>01429 
<a name="l01431"></a>01431         <span class="keywordflow">return</span> ( *nodeQueue.begin() );
<a name="l01432"></a>01432 <span class="comment">/*</span>
<a name="l01434"></a>01434 <span class="comment">        unsigned int nodeCount = ( unsigned int )( dstLeaf - leaves );</span>
<a name="l01435"></a>01435 <span class="comment">        std::sort( leaves, leaves + nodeCount, ScoreSort() );</span>
<a name="l01436"></a>01436 <span class="comment"></span>
<a name="l01438"></a>01438 <span class="comment">        for ( unsigned int i = 0; i &lt; nodeCount; ++i )</span>
<a name="l01439"></a>01439 <span class="comment">                leaves[ i ]-&gt;score = nodeCount - i;</span>
<a name="l01440"></a>01440 <span class="comment"></span>
<a name="l01443"></a>01443 <span class="comment">        STreeNode* primeLeaf = leaves[ 0 ];</span>
<a name="l01444"></a>01444 <span class="comment"></span>
<a name="l01446"></a>01446 <span class="comment">        STreeNode** dstNode = 0;</span>
<a name="l01447"></a>01447 <span class="comment">        do</span>
<a name="l01448"></a>01448 <span class="comment">        {</span>
<a name="l01450"></a>01450 <span class="comment">                STreeNode** curDst = leaves + nodeCount - 2;</span>
<a name="l01451"></a>01451 <span class="comment">                STreeNode** curPair = curDst;</span>
<a name="l01452"></a>01452 <span class="comment"></span>
<a name="l01453"></a>01453 <span class="comment">                ( *curBranch )-&gt;children[ 0 ] = *curPair++;</span>
<a name="l01454"></a>01454 <span class="comment">                ( *curBranch )-&gt;children[ 0 ]-&gt;parent = *curBranch;</span>
<a name="l01455"></a>01455 <span class="comment">                ( *curBranch )-&gt;score = ( *curBranch )-&gt;children[ 0 ]-&gt;score;</span>
<a name="l01456"></a>01456 <span class="comment">         </span>
<a name="l01457"></a>01457 <span class="comment">                ( *curBranch )-&gt;children[ 1 ] = *curPair;</span>
<a name="l01458"></a>01458 <span class="comment">                ( *curBranch )-&gt;children[ 1 ]-&gt;parent = *curBranch;</span>
<a name="l01459"></a>01459 <span class="comment">                ( *curBranch )-&gt;score += ( *curBranch )-&gt;children[ 1 ]-&gt;score;</span>
<a name="l01460"></a>01460 <span class="comment"></span>
<a name="l01463"></a>01463 <span class="comment">                *curDst = *curBranch++;</span>
<a name="l01464"></a>01464 <span class="comment"></span>
<a name="l01466"></a>01466 <span class="comment">                --nodeCount;</span>
<a name="l01467"></a>01467 <span class="comment"></span>
<a name="l01469"></a>01469 <span class="comment">                unsigned int i = nodeCount;</span>
<a name="l01470"></a>01470 <span class="comment">                while ( i-- &gt; 1 )</span>
<a name="l01471"></a>01471 <span class="comment">                {</span>
<a name="l01472"></a>01472 <span class="comment">                        if ( leaves[ i - 1 ]-&gt;score &lt; leaves[ i ]-&gt;score )</span>
<a name="l01473"></a>01473 <span class="comment">                                Swap( leaves[ i - 1 ], leaves[ i ] );</span>
<a name="l01474"></a>01474 <span class="comment">                        else</span>
<a name="l01475"></a>01475 <span class="comment">                                break;</span>
<a name="l01476"></a>01476 <span class="comment">                }</span>
<a name="l01477"></a>01477 <span class="comment">        }</span>
<a name="l01478"></a>01478 <span class="comment">        while ( nodeCount &gt; 1 );</span>
<a name="l01479"></a>01479 <span class="comment"></span>
<a name="l01481"></a>01481 <span class="comment">        if ( minDepth )</span>
<a name="l01482"></a>01482 <span class="comment">        {</span>
<a name="l01484"></a>01484 <span class="comment">                unsigned int minNodeDepth = 0;</span>
<a name="l01485"></a>01485 <span class="comment">                while ( primeLeaf != *leaves )</span>
<a name="l01486"></a>01486 <span class="comment">                {</span>
<a name="l01487"></a>01487 <span class="comment">                        primeLeaf = primeLeaf-&gt;parent;</span>
<a name="l01488"></a>01488 <span class="comment">                        ++minNodeDepth;</span>
<a name="l01489"></a>01489 <span class="comment">                }</span>
<a name="l01490"></a>01490 <span class="comment"></span>
<a name="l01492"></a>01492 <span class="comment">                *minDepth = minNodeDepth;</span>
<a name="l01493"></a>01493 <span class="comment">        }</span>
<a name="l01494"></a>01494 <span class="comment"></span>
<a name="l01496"></a>01496 <span class="comment">        return *leaves;</span>
<a name="l01497"></a>01497 <span class="comment">*/</span>
<a name="l01498"></a>01498 }
<a name="l01499"></a>01499 
<a name="l01500"></a>01500 <span class="comment">//----------------------------------------------------------</span>
<a name="l01501"></a>01501 <span class="keywordtype">void</span>
<a name="l01502"></a>01502 BuildBitCodes( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* lengths, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* scores )
<a name="l01503"></a>01503 {
<a name="l01505"></a>01505         STreeNode nodes[ 511 ];
<a name="l01506"></a>01506         STreeNode* leaves = nodes;
<a name="l01507"></a>01507         STreeNode* branches = nodes + 256;
<a name="l01508"></a>01508         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 256; ++i )
<a name="l01509"></a>01509         {
<a name="l01510"></a>01510                 leaves[ i ].value = i;
<a name="l01511"></a>01511                 leaves[ i ].score = scores[ i ];
<a name="l01512"></a>01512                 leaves[ i ].parent = 0;
<a name="l01513"></a>01513                 leaves[ i ].children[ 0 ] = leaves[ i ].children[ 1 ] = 0;
<a name="l01514"></a>01514         }
<a name="l01515"></a>01515 
<a name="l01517"></a>01517         std::sort( leaves, leaves + 256, ScoreSort() );
<a name="l01518"></a>01518 
<a name="l01520"></a>01520         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nodeCount = 0;
<a name="l01521"></a>01521         <span class="keywordflow">while</span> ( leaves[ nodeCount ].score != 0 )
<a name="l01522"></a>01522                 ++nodeCount;
<a name="l01523"></a>01523 
<a name="l01525"></a>01525         STreeNode** dstNode = 0;
<a name="l01526"></a>01526         <span class="keywordflow">do</span>
<a name="l01527"></a>01527         {
<a name="l01529"></a>01529                 STreeNode** curDst = leaves + nodeCount - 2;
<a name="l01530"></a>01530                 STreeNode** curPair = curDst;
<a name="l01531"></a>01531 
<a name="l01532"></a>01532                 ( *curBranch )-&gt;children[ 0 ] = *curPair++;
<a name="l01533"></a>01533                 ( *curBranch )-&gt;children[ 0 ]-&gt;parent = *curBranch;
<a name="l01534"></a>01534                 ( *curBranch )-&gt;score = ( *curBranch )-&gt;children[ 0 ]-&gt;score;
<a name="l01535"></a>01535          
<a name="l01536"></a>01536                 ( *curBranch )-&gt;children[ 1 ] = *curPair;
<a name="l01537"></a>01537                 ( *curBranch )-&gt;children[ 1 ]-&gt;parent = *curBranch;
<a name="l01538"></a>01538                 ( *curBranch )-&gt;score += ( *curBranch )-&gt;children[ 1 ]-&gt;score;
<a name="l01539"></a>01539 
<a name="l01542"></a>01542                 *curDst = *curBranch++;
<a name="l01543"></a>01543 
<a name="l01545"></a>01545                 --nodeCount;
<a name="l01546"></a>01546 
<a name="l01548"></a>01548                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = nodeCount;
<a name="l01549"></a>01549                 <span class="keywordflow">while</span> ( i-- &gt; 1 )
<a name="l01550"></a>01550                 {
<a name="l01551"></a>01551                         <span class="keywordflow">if</span> ( leaves[ i - 1 ]-&gt;score &lt; leaves[ i ]-&gt;score )
<a name="l01552"></a>01552                                 <a class="code" href="common__afx_8h.html#400f1491dc09805bdbb254cb258e7b41">Swap</a>( leaves[ i - 1 ], leaves[ i ] );
<a name="l01553"></a>01553                         <span class="keywordflow">else</span>
<a name="l01554"></a>01554                                 <span class="keywordflow">break</span>;
<a name="l01555"></a>01555                 }
<a name="l01556"></a>01556         }
<a name="l01557"></a>01557         <span class="keywordflow">while</span> ( nodeCount &gt; 1 );
<a name="l01558"></a>01558 
<a name="l01560"></a>01560         <span class="keywordflow">return</span> *leaves;
<a name="l01561"></a>01561 }
<a name="l01562"></a>01562 <span class="preprocessor">#endif</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Feb 13 17:19:50 2009 for Bootstrap Engine by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
