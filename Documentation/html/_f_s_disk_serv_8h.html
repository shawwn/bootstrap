<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Bootstrap Engine: C:/Bootstrap/ProjectBX/Documentation/Code/Engine/FileSystem/FSDiskServ.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>C:/Bootstrap/ProjectBX/Documentation/Code/Engine/FileSystem/FSDiskServ.h File Reference</h1>
<p>
<a href="_f_s_disk_serv_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_f_s_file_read_buffer__t.html">SFSFileReadBuffer_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">File structures.  <a href="struct_s_f_s_file_read_buffer__t.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_f_s_file_write_buffer__t.html">SFSFileWriteBuffer_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_f_s_file_map__t.html">SFSFileMap_t</a></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_s_disk_serv_8h.html#2814b42b6973facb8a5c61d548a0f7df">FS_FILE_FLAG_CREATE_ALWAYS</a>&nbsp;&nbsp;&nbsp;0x0001</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Purpose: To provide a platform independent wrapper around a disk.  <a href="#2814b42b6973facb8a5c61d548a0f7df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_s_disk_serv_8h.html#b66b8115f52b2492ba9bc3362a9e9da1">FS_FILE_FLAG_OPEN_ALWAYS</a>&nbsp;&nbsp;&nbsp;0x0002</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_s_disk_serv_8h.html#60eb9079b948d946a7cd7eb3741741b3">FS_FILE_FLAG_READ</a>&nbsp;&nbsp;&nbsp;0x0004</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_s_disk_serv_8h.html#1ca62fb541490d8da3caa283ef137664">FS_FILE_FLAG_WRITE</a>&nbsp;&nbsp;&nbsp;0x0008</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_s_disk_serv_8h.html#c42ca6e82a1a313d7191ec0177a0596a">FS_FILE_FLAG_CONTIGUOUS</a>&nbsp;&nbsp;&nbsp;0x0010</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_s_disk_serv_8h.html#0f6bbf8731c9cf9859810948ea751be8">FS_FILE_FLAG_USE_DMA</a>&nbsp;&nbsp;&nbsp;0x0020</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_s_disk_serv_8h.html#08eb85ecc5402f34f9ef86c27f178c72">FS_FILE_WRITE_REORDER</a>&nbsp;&nbsp;&nbsp;0x0040</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_s_disk_serv_8h.html#5b4710c708ad243f91bc75b60a322892">FS_FILE_BEGIN</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move method specifiers.  <a href="#5b4710c708ad243f91bc75b60a322892"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_s_disk_serv_8h.html#75c46608ada8f762e8765bb5ca189aa8">FS_FILE_CURRENT</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The FS_FILE_CURRENT seeks from the current file pointer.  <a href="#75c46608ada8f762e8765bb5ca189aa8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_s_disk_serv_8h.html#b2f0491d3f1f2e8028151cacb7de0278">FS_FILE_END</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The FS_FILE_END seeks from the end of the file.  <a href="#b2f0491d3f1f2e8028151cacb7de0278"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct <a class="el" href="struct_s_f_s_file_read_buffer__t.html">SFSFileReadBuffer_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_s_disk_serv_8h.html#c26c5736857c03ad091229ad0a0faa80">SFSFileReadBuffer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">File structures.  <a href="#c26c5736857c03ad091229ad0a0faa80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct <a class="el" href="struct_s_f_s_file_write_buffer__t.html">SFSFileWriteBuffer_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_s_disk_serv_8h.html#bc15fed2b9242609aa8aaabdf46697f4">SFSFileWriteBuffer</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct <a class="el" href="struct_s_f_s_file_map__t.html">SFSFileMap_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_s_disk_serv_8h.html#c285a0a294598faae9d009f6a1594575">SFSFileMap</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_s_disk_serv_8h.html#639bb9787444e8c425eec0256793d968">FS_ScanDrives</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">File management functions.  <a href="#639bb9787444e8c425eec0256793d968"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_s_disk_serv_8h.html#64815f6582883caa8b5e134620e36d47">FS_OpenFile</a> (const <a class="el" href="filesystem__afx_8h.html#08b81c947811e6def5d8994fd4d76481">FSchar</a> *<a class="el" href="glext__bak_8h.html#bb62efe59ccdd153ce42e1a418352209">name</a>, unsigned int <a class="el" href="_u_t_message_8h.html#0a3c0b351ab09281b662a9ff4f900a53">flags</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_s_disk_serv_8h.html#5a68c779c26cd02b2f7b17851f363683">FS_CloseFile</a> (void *handle)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="filesystem__afx_8h.html#2dfedf2033eee861d23c808f79ed5837">FSsize</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_s_disk_serv_8h.html#06899e7652bf3e71c758ff036404d635">FS_GetFileSize</a> (void *handle)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_s_disk_serv_8h.html#9e21afbbba101c7dc7be9a43fd5291f6">FS_ReadFile</a> (<a class="el" href="struct_s_f_s_file_read_buffer__t.html">SFSFileReadBuffer</a> *<a class="el" href="glext__bak_8h.html#92034251bfd455d524a9b5610cddba00">dst</a>, void *file, <a class="el" href="filesystem__afx_8h.html#2dfedf2033eee861d23c808f79ed5837">FSsize</a> <a class="el" href="glext__bak_8h.html#a782f3aea23e3c30029c811241dc2c82">offset</a>, unsigned int <a class="el" href="glext__bak_8h.html#3d1e3edfcf61ca2d831883e1afbad89e">size</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_s_disk_serv_8h.html#c7abe5c9b19a9611de00573a09fd3a61">FS_WriteFile</a> (void *file, <a class="el" href="filesystem__afx_8h.html#2dfedf2033eee861d23c808f79ed5837">FSsize</a> <a class="el" href="glext__bak_8h.html#a782f3aea23e3c30029c811241dc2c82">offset</a>, <a class="el" href="struct_s_f_s_file_write_buffer__t.html">SFSFileWriteBuffer</a> *<a class="el" href="glext__bak_8h.html#72e0fdf0f845ded60b1fada9e9195cd7">src</a>, unsigned int <a class="el" href="glext__bak_8h.html#3d1e3edfcf61ca2d831883e1afbad89e">size</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_s_disk_serv_8h.html#b8abbd85f1942b0f3dca1793ea4e8978">FS_Wait</a> (volatile int *gate)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_s_disk_serv_8h.html#013362d3615068eee7220194a88a4d73">FS_IsComplete</a> (volatile int *gate)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">waits for and resets the gate's value.  <a href="#013362d3615068eee7220194a88a4d73"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_s_disk_serv_8h.html#34306284dd0c7f5c8f91de947b3e43f1">FS_IsReadComplete</a> (<a class="el" href="struct_s_f_s_file_read_buffer__t.html">SFSFileReadBuffer</a> *readBuffer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">checks and resets the gate's value.  <a href="#34306284dd0c7f5c8f91de947b3e43f1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_s_disk_serv_8h.html#da15545e379beea3118877a61f7c4df6">FS_IsWriteComplete</a> (<a class="el" href="struct_s_f_s_file_write_buffer__t.html">SFSFileWriteBuffer</a> *writeBuffer)</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="5b4710c708ad243f91bc75b60a322892"></a><!-- doxytag: member="FSDiskServ.h::FS_FILE_BEGIN" ref="5b4710c708ad243f91bc75b60a322892" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FS_FILE_BEGIN&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Move method specifiers. 
<p>
The FS_FILE_BEGIN seeks from the beginning of the file. 
<p>Definition at line <a class="el" href="_f_s_disk_serv_8h-source.html#l00055">55</a> of file <a class="el" href="_f_s_disk_serv_8h-source.html">FSDiskServ.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="75c46608ada8f762e8765bb5ca189aa8"></a><!-- doxytag: member="FSDiskServ.h::FS_FILE_CURRENT" ref="75c46608ada8f762e8765bb5ca189aa8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FS_FILE_CURRENT&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The FS_FILE_CURRENT seeks from the current file pointer. 
<p>

<p>Definition at line <a class="el" href="_f_s_disk_serv_8h-source.html#l00058">58</a> of file <a class="el" href="_f_s_disk_serv_8h-source.html">FSDiskServ.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="b2f0491d3f1f2e8028151cacb7de0278"></a><!-- doxytag: member="FSDiskServ.h::FS_FILE_END" ref="b2f0491d3f1f2e8028151cacb7de0278" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FS_FILE_END&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The FS_FILE_END seeks from the end of the file. 
<p>

<p>Definition at line <a class="el" href="_f_s_disk_serv_8h-source.html#l00061">61</a> of file <a class="el" href="_f_s_disk_serv_8h-source.html">FSDiskServ.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="c42ca6e82a1a313d7191ec0177a0596a"></a><!-- doxytag: member="FSDiskServ.h::FS_FILE_FLAG_CONTIGUOUS" ref="c42ca6e82a1a313d7191ec0177a0596a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FS_FILE_FLAG_CONTIGUOUS&nbsp;&nbsp;&nbsp;0x0010          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The FS_FILE_FLAG_CONTIGUOUS flag is only valid when combined with FS_FILE_FLAG_CREATE. This flag tells the system to try and create the file on a contiguous section of the disk for optimal access performance. 
<p>Definition at line <a class="el" href="_f_s_disk_serv_8h-source.html#l00037">37</a> of file <a class="el" href="_f_s_disk_serv_8h-source.html">FSDiskServ.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="2814b42b6973facb8a5c61d548a0f7df"></a><!-- doxytag: member="FSDiskServ.h::FS_FILE_FLAG_CREATE_ALWAYS" ref="2814b42b6973facb8a5c61d548a0f7df" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FS_FILE_FLAG_CREATE_ALWAYS&nbsp;&nbsp;&nbsp;0x0001          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Purpose: To provide a platform independent wrapper around a disk. 
<p>
File: <a class="el" href="_f_s_disk_serv_8h.html">FSDiskServ.h</a> Author: Kevin Bray Created: 10-21-08 Copyright © 2004 Bootstrap Studios. All rights reserved. File creation flags The FS_FILE_FLAG_CREATE forces the file to be recreated when it's opened. Note that this flag is not valid for read-only drives. 
<p>Definition at line <a class="el" href="_f_s_disk_serv_8h-source.html#l00019">19</a> of file <a class="el" href="_f_s_disk_serv_8h-source.html">FSDiskServ.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="b66b8115f52b2492ba9bc3362a9e9da1"></a><!-- doxytag: member="FSDiskServ.h::FS_FILE_FLAG_OPEN_ALWAYS" ref="b66b8115f52b2492ba9bc3362a9e9da1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FS_FILE_FLAG_OPEN_ALWAYS&nbsp;&nbsp;&nbsp;0x0002          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The FS_FILE_FLAG_OPEN_ALWAYS forces the file to be opened if it already exists, and created if it does not currently exist. 
<p>Definition at line <a class="el" href="_f_s_disk_serv_8h-source.html#l00023">23</a> of file <a class="el" href="_f_s_disk_serv_8h-source.html">FSDiskServ.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="60eb9079b948d946a7cd7eb3741741b3"></a><!-- doxytag: member="FSDiskServ.h::FS_FILE_FLAG_READ" ref="60eb9079b948d946a7cd7eb3741741b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FS_FILE_FLAG_READ&nbsp;&nbsp;&nbsp;0x0004          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The FS_FILE_FLAG_READ flag indicates that the file will be readable. 
<p>Definition at line <a class="el" href="_f_s_disk_serv_8h-source.html#l00027">27</a> of file <a class="el" href="_f_s_disk_serv_8h-source.html">FSDiskServ.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="0f6bbf8731c9cf9859810948ea751be8"></a><!-- doxytag: member="FSDiskServ.h::FS_FILE_FLAG_USE_DMA" ref="0f6bbf8731c9cf9859810948ea751be8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FS_FILE_FLAG_USE_DMA&nbsp;&nbsp;&nbsp;0x0020          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The FS_FILE_FLAG_USE_DMA flag opens the file for DMA based access. With this method, the file must be read and written to in multiples of 2K. 
<p>Definition at line <a class="el" href="_f_s_disk_serv_8h-source.html#l00042">42</a> of file <a class="el" href="_f_s_disk_serv_8h-source.html">FSDiskServ.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="1ca62fb541490d8da3caa283ef137664"></a><!-- doxytag: member="FSDiskServ.h::FS_FILE_FLAG_WRITE" ref="1ca62fb541490d8da3caa283ef137664" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FS_FILE_FLAG_WRITE&nbsp;&nbsp;&nbsp;0x0008          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The FS_FILE_FLAG_WRITE flag indicates that the file will be writable. Note that this flag is not valid for read-only drives. 
<p>Definition at line <a class="el" href="_f_s_disk_serv_8h-source.html#l00031">31</a> of file <a class="el" href="_f_s_disk_serv_8h-source.html">FSDiskServ.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="08eb85ecc5402f34f9ef86c27f178c72"></a><!-- doxytag: member="FSDiskServ.h::FS_FILE_WRITE_REORDER" ref="08eb85ecc5402f34f9ef86c27f178c72" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FS_FILE_WRITE_REORDER&nbsp;&nbsp;&nbsp;0x0040          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The FS_FILE_WRITE_REORDER flag tells the file system that writes can be re-ordered with respect to reads and writes. Caution must be used with this flag as overlapping reads and writes may produce different results at different times. 
<p>Definition at line <a class="el" href="_f_s_disk_serv_8h-source.html#l00048">48</a> of file <a class="el" href="_f_s_disk_serv_8h-source.html">FSDiskServ.h</a>.</p>

</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="c285a0a294598faae9d009f6a1594575"></a><!-- doxytag: member="FSDiskServ.h::SFSFileMap" ref="c285a0a294598faae9d009f6a1594575" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_s_f_s_file_map__t.html">SFSFileMap_t</a>  <a class="el" href="struct_s_f_s_file_map__t.html">SFSFileMap</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c26c5736857c03ad091229ad0a0faa80"></a><!-- doxytag: member="FSDiskServ.h::SFSFileReadBuffer" ref="c26c5736857c03ad091229ad0a0faa80" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_s_f_s_file_read_buffer__t.html">SFSFileReadBuffer_t</a>  <a class="el" href="struct_s_f_s_file_read_buffer__t.html">SFSFileReadBuffer</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
File structures. 
<p>

</div>
</div><p>
<a class="anchor" name="bc15fed2b9242609aa8aaabdf46697f4"></a><!-- doxytag: member="FSDiskServ.h::SFSFileWriteBuffer" ref="bc15fed2b9242609aa8aaabdf46697f4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_s_f_s_file_write_buffer__t.html">SFSFileWriteBuffer_t</a>  <a class="el" href="struct_s_f_s_file_write_buffer__t.html">SFSFileWriteBuffer</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="5a68c779c26cd02b2f7b17851f363683"></a><!-- doxytag: member="FSDiskServ.h::FS_CloseFile" ref="5a68c779c26cd02b2f7b17851f363683" args="(void *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FS_CloseFile           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>handle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
get the file's entry.<p>
ensure that that handle is set to the invalid value. Simply return if the file has already been closed.<p>
flush the drive's queue to ensure that all read and write operations are finished.<p>
close the Win32 file.<p>
free the file-entry. 
<p>Definition at line <a class="el" href="_f_s_disk_serv___w32_8cpp-source.html#l00328">328</a> of file <a class="el" href="_f_s_disk_serv___w32_8cpp-source.html">FSDiskServ_W32.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="06899e7652bf3e71c758ff036404d635"></a><!-- doxytag: member="FSDiskServ.h::FS_GetFileSize" ref="06899e7652bf3e71c758ff036404d635" args="(void *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="filesystem__afx_8h.html#2dfedf2033eee861d23c808f79ed5837">FSsize</a> FS_GetFileSize           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>handle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
get the file's entry.<p>
flush the drive's queue to ensure that all write operations are finished.<p>
now get the file's size.<p>
return the file size. 
<p>Definition at line <a class="el" href="_f_s_disk_serv___w32_8cpp-source.html#l00357">357</a> of file <a class="el" href="_f_s_disk_serv___w32_8cpp-source.html">FSDiskServ_W32.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="013362d3615068eee7220194a88a4d73"></a><!-- doxytag: member="FSDiskServ.h::FS_IsComplete" ref="013362d3615068eee7220194a88a4d73" args="(volatile int *gate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FS_IsComplete           </td>
          <td>(</td>
          <td class="paramtype">volatile int *&nbsp;</td>
          <td class="paramname"> <em>gate</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
waits for and resets the gate's value. 
<p>

<p>
Return true if we reset the gate from non-zero to 0. 
<p>Definition at line <a class="el" href="_f_s_disk_serv___w32_8cpp-source.html#l00467">467</a> of file <a class="el" href="_f_s_disk_serv___w32_8cpp-source.html">FSDiskServ_W32.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="34306284dd0c7f5c8f91de947b3e43f1"></a><!-- doxytag: member="FSDiskServ.h::FS_IsReadComplete" ref="34306284dd0c7f5c8f91de947b3e43f1" args="(SFSFileReadBuffer *readBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FS_IsReadComplete           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_f_s_file_read_buffer__t.html">SFSFileReadBuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>readBuffer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
checks and resets the gate's value. 
<p>

<p>Definition at line <a class="el" href="_f_s_disk_serv___w32_8cpp-source.html#l00474">474</a> of file <a class="el" href="_f_s_disk_serv___w32_8cpp-source.html">FSDiskServ_W32.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="da15545e379beea3118877a61f7c4df6"></a><!-- doxytag: member="FSDiskServ.h::FS_IsWriteComplete" ref="da15545e379beea3118877a61f7c4df6" args="(SFSFileWriteBuffer *writeBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FS_IsWriteComplete           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_f_s_file_write_buffer__t.html">SFSFileWriteBuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>writeBuffer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="_f_s_disk_serv___w32_8cpp-source.html#l00480">480</a> of file <a class="el" href="_f_s_disk_serv___w32_8cpp-source.html">FSDiskServ_W32.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="64815f6582883caa8b5e134620e36d47"></a><!-- doxytag: member="FSDiskServ.h::FS_OpenFile" ref="64815f6582883caa8b5e134620e36d47" args="(const FSchar *name, unsigned int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* FS_OpenFile           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="filesystem__afx_8h.html#08b81c947811e6def5d8994fd4d76481">FSchar</a> *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
First, immediately open the file. determine the Win32 access flags.<p>
determine the Win32 creation flags.<p>
determine the Win32 attribute flags.<p>
determine the Win32 file sharing flags.<p>
map the incoming string from UTF-8 to UCS-2.<p>
try open the file. If the file cannot be opened, simply return NULL.<p>
determine the length of the full path name of the file.<p>
get the file's full path name.<p>
Now determine what drive the file lies on.<p>
if we have a drive specifier, get the drive information.<p>
free the full path.<p>
free the UCS-2 string.<p>
ensure that *nothing* about the file is cached in memory.<p>
if we got here, then we need to grab a new file entry to return to the user. Spin until we gain control of the free list.<p>
allocate an item from the free list.<p>
make sure there is room for a new block.<p>
allocate file structures, aligned on 2K boundaries. Note that we simply use the alignment to determine where new memory blocks begin to keep from having to track blocks. This may be wasteful, depending on how the <a class="el" href="common__afx_8cpp.html#408828bf7887e862154788b40930b54a" title="aligned memory allocation">AlignedAlloc()</a> is implemented.<p>
link the file structures together.<p>
terminate the last link with null.<p>
register the block and advance the '_freeRegistered' count.<p>
grab a free file entry.<p>
release the free list gate.<p>
fill out the file-entry's data.<p>
get the file's physical address.<p>
if we successfully issued a command for the file's physical address, set it to the file entry. Otherwise, just assume that the file is at location 0. Note that on NTFS systems, small files are stored in the MFT if possible.<p>
wait for the DeviceIoControl() operation to complete.<p>
store the file's location on the disk.<p>
free the event we created for the DeviceIoControl operation.<p>
return the file-entry pointer. 
<p>Definition at line <a class="el" href="_f_s_disk_serv___w32_8cpp-source.html#l00167">167</a> of file <a class="el" href="_f_s_disk_serv___w32_8cpp-source.html">FSDiskServ_W32.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="9e21afbbba101c7dc7be9a43fd5291f6"></a><!-- doxytag: member="FSDiskServ.h::FS_ReadFile" ref="9e21afbbba101c7dc7be9a43fd5291f6" args="(SFSFileReadBuffer *dst, void *file, FSsize offset, unsigned int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FS_ReadFile           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_f_s_file_read_buffer__t.html">SFSFileReadBuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="filesystem__afx_8h.html#2dfedf2033eee861d23c808f79ed5837">FSsize</a>&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
get the file handle.<p>
acquire the push lock.<p>
determine if there is room on the queue. If not, we need to wait until there is.<p>
issue the read on our worker thread.<p>
fill out the current operation.<p>
if we got here, then the command can be safely issued.<p>
advance the push index.<p>
release the push lock. 
<p>Definition at line <a class="el" href="_f_s_disk_serv___w32_8cpp-source.html#l00375">375</a> of file <a class="el" href="_f_s_disk_serv___w32_8cpp-source.html">FSDiskServ_W32.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="639bb9787444e8c425eec0256793d968"></a><!-- doxytag: member="FSDiskServ.h::FS_ScanDrives" ref="639bb9787444e8c425eec0256793d968" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FS_ScanDrives           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
File management functions. 
<p>

<p>
enumerate through logical drives. 
<p>Definition at line <a class="el" href="_f_s_disk_serv___w32_8cpp-source.html#l00154">154</a> of file <a class="el" href="_f_s_disk_serv___w32_8cpp-source.html">FSDiskServ_W32.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="b8abbd85f1942b0f3dca1793ea4e8978"></a><!-- doxytag: member="FSDiskServ.h::FS_Wait" ref="b8abbd85f1942b0f3dca1793ea4e8978" args="(volatile int *gate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FS_Wait           </td>
          <td>(</td>
          <td class="paramtype">volatile int *&nbsp;</td>
          <td class="paramname"> <em>gate</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
wait for a file operation to be completed. 
<p>Definition at line <a class="el" href="_f_s_disk_serv___w32_8cpp-source.html#l00459">459</a> of file <a class="el" href="_f_s_disk_serv___w32_8cpp-source.html">FSDiskServ_W32.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="c7abe5c9b19a9611de00573a09fd3a61"></a><!-- doxytag: member="FSDiskServ.h::FS_WriteFile" ref="c7abe5c9b19a9611de00573a09fd3a61" args="(void *file, FSsize offset, SFSFileWriteBuffer *src, unsigned int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FS_WriteFile           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="filesystem__afx_8h.html#2dfedf2033eee861d23c808f79ed5837">FSsize</a>&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_f_s_file_write_buffer__t.html">SFSFileWriteBuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
get the file handle.<p>
acquire the push lock.<p>
determine if there is room on the queue. If not, we need to wait until there is.<p>
issue the write on our worker thread.<p>
fill out the current operation.<p>
if we got here, then the command can be safely issued.<p>
advance the push index.<p>
release the push lock. 
<p>Definition at line <a class="el" href="_f_s_disk_serv___w32_8cpp-source.html#l00417">417</a> of file <a class="el" href="_f_s_disk_serv___w32_8cpp-source.html">FSDiskServ_W32.cpp</a>.</p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Feb 13 17:20:01 2009 for Bootstrap Engine by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
